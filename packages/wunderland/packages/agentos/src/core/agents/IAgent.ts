/**
 * @fileoverview Defines the IAgent interface, representing the core contract for any
 * intelligent agent within the AgentOS ecosystem. Agents are the primary actors
 * responsible for processing user inputs (or other stimuli), interacting with AI models
 * (LLMs), utilizing tools to perform actions, managing conversation context, and
 * generating coherent and actionable outputs.
 *
 * This interface is designed to be flexible enough to accommodate various types of agents,
 * from simple task-oriented bots to complex, persona-driven entities like GMIs, or
 * specialized agents within an Agent Pool.
 * @module backend/agentos/core/agents/IAgent
 */

import { ConversationContext } from '../conversation/ConversationContext';
import { Tool } from './tools/Tool'; // Assuming Tool is a class/interface representing an executable tool
import { UIComponentSpecification } from '../ui/IUIComponent'; // Assuming this defines UI block structure
import { AgentConfig } from './AgentCore'; // AgentConfig will be defined in AgentCore.ts

/**
 * Represents a request from an agent to execute a specific tool.
 * This structure provides all necessary information for the ToolExecutor to dispatch the call.
 * @interface AgentToolCall
 */
export interface AgentToolCall {
  /**
   * A unique identifier for this specific tool call instance, typically generated by the LLM or agent.
   * This ID is crucial for correlating the call with its subsequent result, especially in asynchronous operations.
   * @type {string}
   * @example "tool_call_12345abc"
   */
  callId: string;

  /**
   * The unique identifier of the tool to be executed. This ID must match a tool
   * registered and available to the agent via the ToolExecutor.
   * @type {string}
   * @example "web_search_tool", "code_interpreter_tool"
   */
  toolId: string;

  /**
   * The arguments to be passed to the tool's execution method.
   * This should be a JavaScript object where keys are argument names and values are their corresponding values,
   * matching the tool's defined parameter schema.
   * @type {Record<string, any>}
   * @example { "query": "latest TypeScript features", "num_results": 5 }
   */
  arguments: Record<string, any>;
}

/**
 * Represents the output produced by an agent after processing a turn or handling a tool result.
 * This is a comprehensive structure that can convey various types of information back to the orchestrator or user.
 * @interface AgentOutput
 */
export interface AgentOutput {
  /**
   * The primary textual response generated by the agent.
   * This could be a direct answer, an explanation, a question, or any other conversational text.
   * @type {string}
   * @optional
   */
  responseText?: string;

  /**
   * Optional structured data that the agent wishes to output, beyond plain text.
   * This could be JSON, XML, or any other format, useful for programmatic consumption.
   * The key could indicate the type or purpose of the data.
   * @type {Record<string, any>}
   * @optional
   * @example { "codeBlock": { "language": "python", "code": "print('Hello')" }, "analysisSummary": { ... } }
   */
  formattedData?: Record<string, any>;

  /**
   * An array of specifications for UI components that the agent requests to be rendered
   * on the client-side. This enables agents to drive dynamic user interfaces.
   * @type {UIComponentSpecification[]}
   * @optional
   */
  uiComponents?: UIComponentSpecification[];

  /**
   * An array of tool calls that the agent has decided to make to accomplish its current goal.
   * If present, the orchestrator will typically execute these tools and then feed their results
   * back to the agent via the `handleToolResult` method.
   * @type {AgentToolCall[]}
   * @optional
   */
  toolCalls?: AgentToolCall[];

  /**
   * The raw, unaltered response from the underlying AI model (e.g., LLM), if applicable.
   * This is primarily for debugging, logging, or advanced use cases where direct access to the model's
   * output (including metadata, logprobs, etc.) is needed.
   * @type {any}
   * @optional
   */
  rawModelResponse?: any;

  /**
   * If an error occurred during the agent's processing for this turn, this field will contain
   * a human-readable error message or a structured error object.
   * @type {string | Error | object}
   * @optional
   */
  error?: string | Error | object;

  /**
   * Arbitrary metadata that the agent can attach to its output.
   * This can be used for logging, tracing, passing session-specific information, or other custom purposes.
   * @type {Record<string, any>}
   * @optional
   * @example { "confidenceScore": 0.85, "alternativeResponsesConsidered": 3 }
   */
  metadata?: Record<string, any>;

  /**
   * A boolean flag indicating whether the agent considers its current task or interaction turn
   * to be complete.
   * - If `true`, the orchestrator may consider the agent's turn finished.
   * - If `false` (e.g., after requesting tool calls), the orchestrator expects to interact further
   * with the agent in the current turn (e.g., by providing tool results).
   * @type {boolean}
   */
  isComplete: boolean;
}

/**
 * Defines the core contract for an Agent within the AgentOS framework.
 * Implementations of this interface will encapsulate the logic, state, and
 * capabilities of a specific type of intelligent agent.
 * @interface IAgent
 */
export interface IAgent {
  /**
   * A unique identifier for this specific agent instance or type.
   * @readonly
   * @type {string}
   */
  readonly id: string;

  /**
   * A human-readable name for the agent.
   * @readonly
   * @type {string}
   * @example "CustomerSupportAgent", "CodeGenerationAssistant"
   */
  readonly name: string;

  /**
   * A brief description of the agent's purpose, capabilities, and intended use cases.
   * @readonly
   * @type {string}
   */
  readonly description: string;

  /**
   * The full configuration object that defines this agent's properties,
   * including its type, system prompt, model preferences, and any pool options if applicable.
   * This provides transparency into how the agent is configured.
   * @readonly
   * @type {AgentConfig}
   */
  readonly agentConfig: AgentConfig;

  /**
   * Processes a single turn of interaction. This is the primary method called by an
   * orchestrator (like AgentOrchestrator or GMIManager) to make the agent "act".
   * The agent will use the user input and conversation context to decide on its
   * next actions, which may include generating text, calling tools, or updating its state.
   *
   * @async
   * @param {string | null} userInput - The latest textual input from the user for this turn.
   * Can be `null` if the agent is acting autonomously (e.g., based on a previous tool result or internal trigger)
   * or if the input is purely non-textual and handled through other mechanisms.
   * @param {ConversationContext} conversationContext - The current state of the conversation,
   * including message history, metadata, and potentially summaries. The agent should use this
   * to maintain context and coherence.
   * @param {Tool[]} [availableTools] - An optional array of `Tool` instances that are
   * available to the agent for execution during this turn. The agent should only request
   * tools from this list or tools it intrinsically knows it can use.
   * @returns {Promise<AgentOutput>} A promise that resolves to an `AgentOutput` object,
   * representing the agent's response and any requested actions for this turn.
   * @throws {Error} If a critical, unrecoverable error occurs during processing.
   */
  processTurn(
    userInput: string | null,
    conversationContext: ConversationContext,
    availableTools?: Tool[]
  ): Promise<AgentOutput>;

  /**
   * Handles the result of a tool call that this agent previously requested in an `AgentOutput`.
   * After a tool is executed by the ToolExecutor, its result is passed back to the agent
   * through this method. The agent can then process this result, update its state or context,
   * and decide on its next actions (which might involve further LLM calls or generating a final response).
   *
   * @async
   * @param {string} toolCallId - The unique ID of the original `AgentToolCall` this result pertains to.
   * This allows the agent to correlate the result with its earlier request.
   * @param {any} toolOutput - The output data from the tool execution. The type of this data
   * is specific to the tool that was called. It could be a simple value, a complex object, or an error.
   * @param {string} toolName - The name/ID of the tool that was executed. This provides context
   * to the agent about which tool's result it is handling.
   * @param {ConversationContext} conversationContext - The current conversation context, which
   * should ideally include the original tool call request and will be updated with the tool result message.
   * @returns {Promise<AgentOutput>} A promise that resolves to the agent's subsequent output after
   * processing the tool result. This could be a final response or another set of actions (e.g., more tool calls).
   * @throws {Error} If a critical, unrecoverable error occurs while handling the tool result.
   */
  handleToolResult(
    toolCallId: string,
    toolOutput: any,
    toolName: string,
    conversationContext: ConversationContext,
  ): Promise<AgentOutput>;

  /**
   * Allows the agent to perform any necessary setup or initialization logic when it is
   * first created or loaded. This can include loading resources, setting up internal state,
   * or validating its configuration.
   *
   * @async
   * @param {Record<string, any>} [config] - Optional agent-specific configuration parameters
   * that might override or supplement its primary `AgentConfig`. This allows for dynamic
   * adjustments at instantiation time.
   * @returns {Promise<void>} A promise that resolves when initialization is complete.
   * @throws {Error} If initialization fails.
   */
  initialize?(config?: Record<string, any>): Promise<void>;

  /**
   * Resets the agent's internal state to its initial condition. This is typically called
   * at the beginning of a new conversation or session, or if the agent needs to be "cleared"
   * for any reason. The exact behavior of reset (e.g., clearing memory, resetting parameters)
   * is specific to the agent's implementation.
   *
   * @returns {void}
   */
  reset?(): void;

  /**
   * Optional method for an agent to gracefully handle internal, unexpected errors.
   * If implemented, this allows the agent to attempt to generate a user-friendly
   * explanation or apology instead of just letting a raw exception propagate.
   *
   * @async
   * @param {string | Error} internalErrorDescription - A description or instance of the internal error.
   * @param {ConversationContext} conversationContext - The conversation context at the time of the error.
   * @param {boolean} [isFatalForTurn=true] - If true, implies the current turn cannot proceed meaningfully.
   * @returns {Promise<AgentOutput>} An `AgentOutput` typically containing a user-facing error message.
   */
  handleInternalAgentError?(
    internalErrorDescription: string | Error,
    conversationContext: ConversationContext,
    isFatalForTurn?: boolean
  ): Promise<AgentOutput>;
}