#!/usr/bin/env node

/**
 * pull-source.mjs — Prebuild script that makes the wunderland package source
 * available for TypeDoc API generation.
 *
 * - In the monorepo (local dev): symlinks .source/wunderland/ to the local package
 * - In CI (standalone repo): shallow-clones from GitHub
 *
 * Run: node scripts/pull-source.mjs
 * Auto-runs via `npm run prebuild` before `npm run build`.
 */

import {
   copyFileSync,
   existsSync,
   mkdirSync,
   readFileSync,
   rmSync,
   symlinkSync,
   writeFileSync,
 } from 'node:fs';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { execSync } from 'node:child_process';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, '..');
const SOURCE_DIR = resolve(ROOT, '.source');
const TARGET = resolve(SOURCE_DIR, 'wunderland');
const STATIC_MEDIA_DIR = resolve(ROOT, 'static/docs/_media');
const DOCS_MEDIA_DIR = resolve(ROOT, 'docs/_media');
const LEGACY_PAGES_MEDIA_DIR = resolve(ROOT, 'src/pages/docs/_media');
const PAGES_MEDIA_DIR = resolve(ROOT, 'src/pages/typedoc-media');

// Local monorepo path (when docs-site is inside apps/wunderland-sh/docs-site/)
const LOCAL_PKG = resolve(ROOT, '../../../packages/wunderland');

// GitHub repo URL for CI builds
const REPO_URL = 'https://github.com/jddunn/wunderland.git';

function syncTypedocMedia() {
  // TypeDoc readme gets rewritten to `_media/*` links, but with `trailingSlash: false`
  // those resolve to `/docs/_media/*` (not `/docs/api-reference/_media/*`).
  // We generate actual pages under `/docs/_media/*.md` so Docusaurus link validation
  // treats them as real routes (instead of broken links to raw markdown assets).
  const docsDir = resolve(TARGET, 'docs');
  const assetsDir = resolve(TARGET, 'assets');

  const mdDocs = [
    { name: 'LOCAL_LLM_SETUP', title: 'Local LLM Setup' },
    { name: 'GUARDRAILS', title: 'Guardrails' },
    { name: 'PRESETS_AND_PERMISSIONS', title: 'Presets & Permissions' },
    { name: 'OBSERVABILITY', title: 'Observability' },
  ];

  const assets = [
    { src: resolve(assetsDir, 'wunderland-logo.svg'), dest: 'wunderland-logo.svg' },
    { src: resolve(assetsDir, 'wunderland-logo-light.svg'), dest: 'wunderland-logo-light.svg' },
  ];

  mkdirSync(STATIC_MEDIA_DIR, { recursive: true });
  mkdirSync(DOCS_MEDIA_DIR, { recursive: true });
  mkdirSync(PAGES_MEDIA_DIR, { recursive: true });

  // Docusaurus excludes files/folders that start with "_" by default.
  // Clean up the old generated location (src/pages/docs/_media/*) so we
  // don't keep accumulating ignored artifacts.
  if (existsSync(LEGACY_PAGES_MEDIA_DIR)) {
    rmSync(LEGACY_PAGES_MEDIA_DIR, { recursive: true, force: true });
  }

  // Copy static assets (logos) for markdown pages to reference.
  for (const asset of assets) {
    if (!existsSync(asset.src)) {
      console.warn(`pull-source: Missing media file: ${asset.src}`);
      continue;
    }
    copyFileSync(asset.src, resolve(DOCS_MEDIA_DIR, asset.dest));
    copyFileSync(asset.src, resolve(STATIC_MEDIA_DIR, asset.dest));
  }

  // Generate real Docusaurus routes at `/docs/_media/<NAME>.md`.
  // (File name keeps the `.md` suffix so the route matches TypeDoc's links.)
  for (const doc of mdDocs) {
    const src = resolve(docsDir, `${doc.name}.md`);
    if (!existsSync(src)) {
      console.warn(`pull-source: Missing media doc: ${src}`);
      continue;
    }

    const raw = readFileSync(src, 'utf-8');
    const normalized = raw
      .trim()
      .replaceAll(
        '(../README.md)',
        '(https://github.com/framersai/voice-chat-assistant/blob/master/packages/wunderland/README.md)',
      );

    const slug = `/docs/_media/${doc.name}.md`;

    // Keep as close to original markdown as possible, but add minimal front
    // matter so the page can live outside any "_" folder and still map to the
    // route TypeDoc links to.
    const mdx = `---\ntitle: ${doc.title}\nslug: ${slug}\nunlisted: true\n---\n\n<!-- Generated by scripts/pull-source.mjs from wunderland/docs/${doc.name}.md -->\n\n${normalized}\n`;

    const outPath = resolve(PAGES_MEDIA_DIR, `${doc.name}.mdx`);
    writeFileSync(outPath, mdx, 'utf-8');

    // Keep a source copy in docs/_media for convenience (not a route).
    copyFileSync(src, resolve(DOCS_MEDIA_DIR, `${doc.name}.md`));
  }

  console.log(`pull-source: Synced TypeDoc media routes and assets:\n- ${PAGES_MEDIA_DIR}\n- ${DOCS_MEDIA_DIR}\n- ${STATIC_MEDIA_DIR}\n`);
}

function main() {
  console.log('pull-source: Preparing wunderland source for TypeDoc...\n');

  // If .source/wunderland already exists and has src/index.ts, skip
  if (existsSync(resolve(TARGET, 'src/index.ts'))) {
    console.log('pull-source: Source already present, skipping.\n');
    syncTypedocMedia();
    return;
  }

  // Clean up any stale .source directory
  if (existsSync(SOURCE_DIR)) {
    rmSync(SOURCE_DIR, { recursive: true, force: true });
  }
  mkdirSync(SOURCE_DIR, { recursive: true });

  // Strategy 1: Local monorepo symlink
  if (existsSync(resolve(LOCAL_PKG, 'src/index.ts'))) {
    console.log(`pull-source: Found local package at ${LOCAL_PKG}`);
    console.log('pull-source: Creating symlink...\n');
    symlinkSync(LOCAL_PKG, TARGET, 'dir');
    console.log(`pull-source: Symlinked .source/wunderland/ -> ${LOCAL_PKG}\n`);
    syncTypedocMedia();
    return;
  }

  // Strategy 2: Clone from GitHub (CI environment)
  console.log('pull-source: No local package found, cloning from GitHub...');

  // Use GH_PAT if available (for private repos)
  let cloneUrl = REPO_URL;
  if (process.env.GH_PAT) {
    cloneUrl = REPO_URL.replace('https://', `https://${process.env.GH_PAT}@`);
  }

  try {
    execSync(
      `git clone --depth 1 --single-branch --branch master "${cloneUrl}" "${TARGET}"`,
      { stdio: 'inherit' }
    );
    console.log('\npull-source: Cloned wunderland source successfully.\n');
  } catch (err) {
    console.error('pull-source: Failed to clone wunderland source:', err.message);
    console.error('pull-source: TypeDoc API generation will be skipped.');
    // Create empty directory so build doesn't fail
    mkdirSync(TARGET, { recursive: true });
    return;
  }

  // Verify
  if (!existsSync(resolve(TARGET, 'src/index.ts'))) {
    console.error('pull-source: WARNING — src/index.ts not found in cloned source');
  }

  syncTypedocMedia();
}

main();
