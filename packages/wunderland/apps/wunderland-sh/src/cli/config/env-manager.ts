/**
 * @fileoverview Read/write ~/.wunderland/.env for API keys and secrets.
 * @module wunderland/cli/config/env-manager
 */

import { existsSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import * as path from 'node:path';
import { getConfigDir, ensureConfigDir } from './config-manager.js';
import { ENV_FILE_NAME } from '../constants.js';
import { getAllSecrets } from './secrets.js';

// ── Import Result ────────────────────────────────────────────────────────────

export interface ImportResult {
  /** Total keys parsed from input. */
  total: number;
  /** Keys successfully imported (new). */
  imported: number;
  /** Keys skipped (already set with same value). */
  skipped: number;
  /** Keys updated (existed but different value). */
  updated: number;
  /** Keys not matching any known secret. */
  unrecognized: number;
  /** Per-key action details. */
  details: { key: string; action: 'imported' | 'skipped' | 'updated' | 'unrecognized' }[];
}

/** Resolve the .env file path. */
export function getEnvPath(configDirOverride?: string): string {
  return path.join(getConfigDir(configDirOverride), ENV_FILE_NAME);
}

/** Parse a .env file into a key-value map. */
export function parseEnvFile(contents: string): Record<string, string> {
  const out: Record<string, string> = {};
  for (const rawLine of contents.split('\n')) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) continue;
    const idx = line.indexOf('=');
    if (idx === -1) continue;
    const key = line.slice(0, idx).trim();
    let val = line.slice(idx + 1).trim();
    // Strip surrounding quotes
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
      val = val.slice(1, -1);
    }
    if (key) out[key] = val;
  }
  return out;
}

/** Serialize a key-value map to .env format. */
export function serializeEnvFile(env: Record<string, string>, header?: string): string {
  const lines: string[] = [];
  if (header) {
    lines.push(`# ${header}`);
    lines.push(`# Generated by wunderland setup — ${new Date().toISOString()}`);
    lines.push('');
  }
  for (const [key, val] of Object.entries(env)) {
    if (!key) continue;
    // Quote values with spaces or special chars
    const needsQuote = /[\s#"'\\]/.test(val);
    lines.push(`${key}=${needsQuote ? `"${val}"` : val}`);
  }
  lines.push(''); // trailing newline
  return lines.join('\n');
}

/** Load .env from ~/.wunderland/.env (does NOT set process.env). */
export async function loadEnv(configDirOverride?: string): Promise<Record<string, string>> {
  const filePath = getEnvPath(configDirOverride);
  if (!existsSync(filePath)) return {};

  try {
    const raw = await readFile(filePath, 'utf8');
    return parseEnvFile(raw);
  } catch {
    return {};
  }
}

/** Save .env to disk (creates dir if needed). File permissions: 0600. */
export async function saveEnv(
  env: Record<string, string>,
  configDirOverride?: string,
  header?: string,
): Promise<void> {
  await ensureConfigDir(configDirOverride);
  const filePath = getEnvPath(configDirOverride);
  const content = serializeEnvFile(env, header || 'Wunderland API Keys & Secrets');
  await writeFile(filePath, content, { encoding: 'utf8', mode: 0o600 });
}

/** Merge new keys into existing .env (preserves existing keys). */
export async function mergeEnv(
  newKeys: Record<string, string>,
  configDirOverride?: string,
): Promise<Record<string, string>> {
  const existing = await loadEnv(configDirOverride);
  const merged = { ...existing };
  for (const [key, val] of Object.entries(newKeys)) {
    if (val) merged[key] = val;
  }
  await saveEnv(merged, configDirOverride);
  return merged;
}

/**
 * Load .env files into process.env (same order as existing CLI).
 * Does not overwrite existing env vars.
 */
export async function loadDotEnvIntoProcess(...paths: string[]): Promise<void> {
  for (const filePath of paths) {
    if (!existsSync(filePath)) continue;
    try {
      const raw = await readFile(filePath, 'utf8');
      const parsed = parseEnvFile(raw);
      for (const [k, v] of Object.entries(parsed)) {
        if (!process.env[k]) process.env[k] = v;
      }
    } catch {
      // silently skip unreadable files
    }
  }
}

function collectEnvPathsUpward(startDir: string, filenames: string[]): string[] {
  const out: string[] = [];
  let dir = path.resolve(startDir);

  // Hard cap to prevent pathological traversal in weird FS setups.
  for (let depth = 0; depth < 50; depth += 1) {
    for (const name of filenames) {
      const candidate = path.join(dir, name);
      if (existsSync(candidate)) out.push(candidate);
    }

    const parent = path.dirname(dir);
    if (parent === dir) break;
    dir = parent;
  }

  return out;
}

/**
 * Load .env files from the current working directory *and all parent dirs*,
 * plus the global Wunderland env file (~/.wunderland/.env) as a fallback.
 *
 * Precedence (highest first, because we do NOT overwrite process.env):
 * - nearest `.env.local`
 * - nearest `.env`
 * - parent `.env.local`
 * - parent `.env`
 * - ...
 * - global `~/.wunderland/.env`
 */
export async function loadDotEnvIntoProcessUpward(opts?: {
  startDir?: string;
  includeGlobal?: boolean;
  configDirOverride?: string;
}): Promise<void> {
  const startDir = opts?.startDir ? path.resolve(opts.startDir) : process.cwd();
  const includeGlobal = opts?.includeGlobal !== false;

  const projectEnvPaths = collectEnvPathsUpward(startDir, ['.env.local', '.env']);
  const pathsToLoad = includeGlobal
    ? [...projectEnvPaths, getEnvPath(opts?.configDirOverride)]
    : projectEnvPaths;

  await loadDotEnvIntoProcess(...pathsToLoad);
}

/**
 * Parse a raw .env block (multi-line text) and import recognized keys.
 * Matches keys against known extension secrets from extension-secrets.json.
 * Returns a summary of what was imported.
 */
export async function importEnvBlock(text: string): Promise<ImportResult> {
  // 1. Parse the pasted text as .env format
  const parsed = parseEnvFile(text);
  const parsedKeys = Object.keys(parsed);

  // 2. Load existing env from ~/.wunderland/.env
  const existing = await loadEnv();

  // 3. Build envVar -> secretId lookup from known secret definitions
  const secrets = getAllSecrets();
  const knownEnvVars = new Set(secrets.map((s) => s.envVar));

  // 4. Classify each parsed key
  const result: ImportResult = {
    total: parsedKeys.length,
    imported: 0,
    skipped: 0,
    updated: 0,
    unrecognized: 0,
    details: [],
  };

  const toMerge: Record<string, string> = {};

  for (const key of parsedKeys) {
    const value = parsed[key];

    if (!knownEnvVars.has(key)) {
      // Not a recognized secret env var
      result.unrecognized++;
      result.details.push({ key, action: 'unrecognized' });
      continue;
    }

    if (key in existing && existing[key] === value) {
      // Already set with the same value — skip
      result.skipped++;
      result.details.push({ key, action: 'skipped' });
      continue;
    }

    if (key in existing && existing[key] !== value) {
      // Exists but with a different value — update
      result.updated++;
      result.details.push({ key, action: 'updated' });
      toMerge[key] = value;
      continue;
    }

    // New key — import
    result.imported++;
    result.details.push({ key, action: 'imported' });
    toMerge[key] = value;
  }

  // 5. Merge recognized keys into existing env and save
  if (Object.keys(toMerge).length > 0) {
    await mergeEnv(toMerge);
  }

  return result;
}
