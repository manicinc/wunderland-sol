/**
 * @file IPlanningEngine.ts
 * @description Interface for the AgentOS Planning Engine - enables autonomous goal pursuit,
 * task decomposition, and self-correcting execution plans.
 *
 * The Planning Engine implements cognitive patterns like ReAct (Reasoning + Acting),
 * Chain-of-Thought, and Tree-of-Thought for sophisticated multi-step reasoning.
 *
 * @module AgentOS/Planning
 * @version 1.0.0
 *
 * @example
 * ```typescript
 * const planningEngine = new PlanningEngine(llmProvider, logger);
 *
 * // Generate a plan from a high-level goal
 * const plan = await planningEngine.generatePlan(
 *   'Research and summarize the latest AI safety papers',
 *   { maxSteps: 10, allowToolUse: true }
 * );
 *
 * // Execute with autonomous loop
 * for await (const step of planningEngine.runAutonomousLoop(goal, options)) {
 *   console.log(`Step ${step.index}: ${step.action}`);
 *   if (step.requiresHumanApproval) {
 *     // Handle HITL checkpoint
 *   }
 * }
 * ```
 */

import type { ITool } from '../tools/ITool';

// ============================================================================
// Plan Types
// ============================================================================

/**
 * Represents a single step in an execution plan.
 * Each step contains the reasoning, action, and expected outcome.
 */
export interface PlanStep {
  /** Unique step identifier */
  stepId: string;
  /** Zero-based step index */
  index: number;
  /** The action to take (tool call, reasoning, etc.) */
  action: PlanAction;
  /** Chain-of-thought reasoning for this step */
  reasoning: string;
  /** Expected outcome description */
  expectedOutcome: string;
  /** Dependencies on other step IDs */
  dependsOn: string[];
  /** Estimated token cost for this step */
  estimatedTokens: number;
  /** Confidence score (0-1) in this step's success */
  confidence: number;
  /** Whether this step requires human approval */
  requiresHumanApproval: boolean;
  /** Current execution status */
  status: PlanStepStatus;
  /** Actual result after execution */
  result?: PlanStepResult;
}

/**
 * Status of a plan step during execution.
 */
export type PlanStepStatus =
  | 'pending'
  | 'ready'
  | 'executing'
  | 'awaiting_approval'
  | 'completed'
  | 'failed'
  | 'skipped';

/**
 * The type of action a plan step performs.
 */
export interface PlanAction {
  /** Action type */
  type: PlanActionType;
  /** Tool to invoke (if type is 'tool_call') */
  toolId?: string;
  /** Arguments for tool call */
  toolArgs?: Record<string, unknown>;
  /** Sub-goal to pursue (if type is 'subgoal') */
  subgoal?: string;
  /** Query for information retrieval */
  query?: string;
  /** Content for reasoning/synthesis steps */
  content?: string;
}

/**
 * Types of actions that can appear in a plan.
 */
export type PlanActionType =
  | 'tool_call'        // Invoke a tool
  | 'reasoning'        // Pure reasoning step
  | 'information_gathering' // RAG/search query
  | 'subgoal'          // Recursive goal decomposition
  | 'synthesis'        // Combine results from previous steps
  | 'validation'       // Verify previous step output
  | 'human_input'      // Request human input
  | 'checkpoint';      // Save state for potential rollback

/**
 * Result of executing a plan step.
 */
export interface PlanStepResult {
  /** Whether execution succeeded */
  success: boolean;
  /** Output data from execution */
  output: unknown;
  /** Error message if failed */
  error?: string;
  /** Actual tokens used */
  tokensUsed: number;
  /** Execution duration in ms */
  durationMs: number;
  /** Observations made during execution */
  observations: string[];
}

/**
 * Complete execution plan generated by the planning engine.
 */
export interface ExecutionPlan {
  /** Unique plan identifier */
  planId: string;
  /** Original goal this plan addresses */
  goal: string;
  /** Ordered list of plan steps */
  steps: PlanStep[];
  /** Dependency graph: stepId -> dependent stepIds */
  dependencies: Map<string, string[]>;
  /** Estimated total token cost */
  estimatedTokens: number;
  /** Overall confidence score (0-1) */
  confidenceScore: number;
  /** Plan generation timestamp */
  createdAt: Date;
  /** Planning strategy used */
  strategy: PlanningStrategy;
  /** Metadata about plan generation */
  metadata: PlanMetadata;
}

/**
 * Metadata about how a plan was generated.
 */
export interface PlanMetadata {
  /** Model used for planning */
  modelId: string;
  /** Planning iterations/refinements */
  iterations: number;
  /** Time spent planning in ms */
  planningDurationMs: number;
  /** Alternative plans considered */
  alternativesConsidered: number;
}

// ============================================================================
// Planning Strategies
// ============================================================================

/**
 * Available planning strategies.
 */
export type PlanningStrategy =
  | 'react'            // Reasoning + Acting interleaved
  | 'plan_and_execute' // Full plan then execute
  | 'tree_of_thought'  // Explore multiple reasoning paths
  | 'least_to_most'    // Decompose into simpler subproblems
  | 'self_consistency' // Generate multiple plans, vote on best
  | 'reflexion';       // Plan with self-reflection loops

/**
 * Configuration for plan generation.
 */
export interface PlanningOptions {
  /** Maximum steps allowed in plan */
  maxSteps?: number;
  /** Maximum planning iterations */
  maxIterations?: number;
  /** Minimum confidence threshold */
  minConfidence?: number;
  /** Allow tool usage in plan */
  allowToolUse?: boolean;
  /** Available tools for planning */
  availableTools?: ITool[];
  /** Planning strategy to use */
  strategy?: PlanningStrategy;
  /** Enable human checkpoints */
  enableCheckpoints?: boolean;
  /** Checkpoint frequency (every N steps) */
  checkpointFrequency?: number;
  /** Maximum tokens for entire plan execution */
  maxTotalTokens?: number;
  /** Time limit for planning phase in ms */
  planningTimeoutMs?: number;
}

/**
 * Context provided to the planning engine.
 */
export interface PlanningContext {
  /** Current conversation/session context */
  conversationHistory?: string;
  /** Retrieved relevant context */
  retrievedContext?: string;
  /** User preferences/constraints */
  userConstraints?: string[];
  /** Previously failed approaches */
  failedApproaches?: string[];
  /** Domain-specific knowledge */
  domainContext?: string;
  /** Available resources/capabilities */
  capabilities?: string[];
}

// ============================================================================
// Task Decomposition
// ============================================================================

/**
 * Result of decomposing a complex task into subtasks.
 */
export interface TaskDecomposition {
  /** Original task */
  originalTask: string;
  /** Decomposed subtasks */
  subtasks: SubTask[];
  /** Decomposition reasoning */
  reasoning: string;
  /** Whether decomposition is complete */
  isComplete: boolean;
  /** Suggested execution order */
  executionOrder: string[];
}

/**
 * A subtask resulting from decomposition.
 */
export interface SubTask {
  /** Unique subtask identifier */
  subtaskId: string;
  /** Subtask description */
  description: string;
  /** Complexity estimate (1-10) */
  complexity: number;
  /** Dependencies on other subtasks */
  dependsOn: string[];
  /** Estimated tokens to complete */
  estimatedTokens: number;
  /** Can this be parallelized with others? */
  parallelizable: boolean;
}

// ============================================================================
// Execution Feedback & Refinement
// ============================================================================

/**
 * Feedback from plan execution used for refinement.
 */
export interface ExecutionFeedback {
  /** Plan being executed */
  planId: string;
  /** Step that generated feedback */
  stepId: string;
  /** Type of feedback */
  feedbackType: FeedbackType;
  /** Feedback details */
  details: string;
  /** Suggested correction */
  suggestedCorrection?: string;
  /** Severity of the issue */
  severity: 'info' | 'warning' | 'error' | 'critical';
}

/**
 * Types of execution feedback.
 */
export type FeedbackType =
  | 'step_failed'
  | 'unexpected_output'
  | 'confidence_drop'
  | 'timeout'
  | 'resource_exhausted'
  | 'human_correction'
  | 'validation_failed';

// ============================================================================
// Autonomous Loop Types
// ============================================================================

/**
 * Options for autonomous goal pursuit loop.
 */
export interface AutonomousLoopOptions {
  /** Maximum iterations before stopping */
  maxIterations?: number;
  /** Stop when goal confidence exceeds this */
  goalConfidenceThreshold?: number;
  /** Enable self-reflection between iterations */
  enableReflection?: boolean;
  /** Reflection frequency (every N iterations) */
  reflectionFrequency?: number;
  /** Human approval required for certain actions */
  requireApprovalFor?: PlanActionType[];
  /** Callback for progress updates */
  onProgress?: (progress: LoopProgress) => void;
  /** Callback for human approval requests */
  onApprovalRequired?: (request: ApprovalRequest) => Promise<boolean>;
}

/**
 * Progress update during autonomous loop.
 */
export interface LoopProgress {
  /** Current iteration */
  iteration: number;
  /** Current step being executed */
  currentStep: PlanStep;
  /** Overall progress (0-1) */
  progress: number;
  /** Accumulated observations */
  observations: string[];
  /** Current confidence in goal achievement */
  goalConfidence: number;
  /** Tokens used so far */
  tokensUsed: number;
}

/**
 * Request for human approval during autonomous execution.
 */
export interface ApprovalRequest {
  /** Request identifier */
  requestId: string;
  /** Step requiring approval */
  step: PlanStep;
  /** Reason approval is needed */
  reason: string;
  /** Suggested action */
  suggestedAction: 'approve' | 'modify' | 'reject';
  /** Timeout for response in ms */
  timeoutMs: number;
}

// ============================================================================
// IPlanningEngine Interface
// ============================================================================

/**
 * Interface for the AgentOS Planning Engine.
 *
 * The Planning Engine provides sophisticated cognitive capabilities for
 * autonomous agents, including:
 *
 * - **Goal Decomposition**: Break complex goals into manageable subtasks
 * - **Plan Generation**: Create multi-step execution plans with ReAct pattern
 * - **Self-Correction**: Refine plans based on execution feedback
 * - **Autonomous Loops**: Pursue goals with minimal human intervention
 *
 * @example
 * ```typescript
 * // Generate and execute a plan
 * const engine = new PlanningEngine(llmProvider);
 * const plan = await engine.generatePlan('Build a REST API', {
 *   strategy: 'plan_and_execute',
 *   maxSteps: 20,
 * });
 *
 * for (const step of plan.steps) {
 *   const result = await engine.executeStep(step);
 *   if (!result.success) {
 *     const refined = await engine.refinePlan(plan, {
 *       planId: plan.planId,
 *       stepId: step.stepId,
 *       feedbackType: 'step_failed',
 *       details: result.error!,
 *       severity: 'error',
 *     });
 *   }
 * }
 * ```
 */
export interface IPlanningEngine {
  // ==========================================================================
  // Plan Generation
  // ==========================================================================

  /**
   * Generates a multi-step execution plan from a high-level goal.
   *
   * @param goal - The high-level goal to achieve
   * @param context - Additional context for planning
   * @param options - Planning configuration options
   * @returns Generated execution plan
   *
   * @example
   * ```typescript
   * const plan = await engine.generatePlan(
   *   'Analyze customer feedback and generate a report',
   *   { domainContext: 'E-commerce platform' },
   *   { strategy: 'react', maxSteps: 15 }
   * );
   * ```
   */
  generatePlan(
    goal: string,
    context?: PlanningContext,
    options?: PlanningOptions,
  ): Promise<ExecutionPlan>;

  /**
   * Decomposes a complex task into simpler subtasks.
   *
   * @param task - The task description to decompose
   * @param depth - Maximum decomposition depth (default: 3)
   * @returns Task decomposition result
   */
  decomposeTask(task: string, depth?: number): Promise<TaskDecomposition>;

  /**
   * Validates a plan for feasibility and completeness.
   *
   * @param plan - Plan to validate
   * @returns Validation result with any issues found
   */
  validatePlan(plan: ExecutionPlan): Promise<PlanValidationResult>;

  // ==========================================================================
  // Plan Refinement
  // ==========================================================================

  /**
   * Refines an existing plan based on execution feedback.
   * Uses self-reflection to identify issues and generate corrections.
   *
   * @param plan - Original plan to refine
   * @param feedback - Feedback from execution
   * @returns Refined execution plan
   */
  refinePlan(plan: ExecutionPlan, feedback: ExecutionFeedback): Promise<ExecutionPlan>;

  /**
   * Performs self-reflection on plan execution state.
   *
   * @param plan - Current plan
   * @param executionState - Current execution state
   * @returns Reflection insights and suggested adjustments
   */
  reflect(plan: ExecutionPlan, executionState: ExecutionState): Promise<ReflectionResult>;

  // ==========================================================================
  // Execution
  // ==========================================================================

  /**
   * Executes a single plan step.
   *
   * @param step - Step to execute
   * @param context - Execution context including previous results
   * @returns Step execution result
   */
  executeStep(step: PlanStep, context?: StepExecutionContext): Promise<PlanStepResult>;

  /**
   * Runs an autonomous goal pursuit loop.
   * Yields progress updates and handles self-correction automatically.
   *
   * @param goal - Goal to pursue
   * @param options - Loop configuration
   * @yields Progress updates including current step and observations
   * @returns Final execution summary
   */
  runAutonomousLoop(
    goal: string,
    options?: AutonomousLoopOptions,
  ): AsyncGenerator<LoopProgress, ExecutionSummary, undefined>;

  // ==========================================================================
  // State Management
  // ==========================================================================

  /**
   * Saves current execution state for checkpointing/rollback.
   *
   * @param plan - Plan being executed
   * @param state - Current execution state
   * @returns Checkpoint identifier
   */
  saveCheckpoint(plan: ExecutionPlan, state: ExecutionState): Promise<string>;

  /**
   * Restores execution state from a checkpoint.
   *
   * @param checkpointId - Checkpoint to restore
   * @returns Restored execution state
   */
  restoreCheckpoint(checkpointId: string): Promise<{ plan: ExecutionPlan; state: ExecutionState }>;

  /**
   * Gets the current execution state for a plan.
   *
   * @param planId - Plan identifier
   * @returns Current execution state or null if not found
   */
  getExecutionState(planId: string): ExecutionState | null;
}

// ============================================================================
// Supporting Types
// ============================================================================

/**
 * Result of plan validation.
 */
export interface PlanValidationResult {
  /** Whether plan is valid */
  isValid: boolean;
  /** Validation issues found */
  issues: PlanValidationIssue[];
  /** Suggestions for improvement */
  suggestions: string[];
}

/**
 * A single plan validation issue.
 */
export interface PlanValidationIssue {
  /** Issue severity */
  severity: 'warning' | 'error';
  /** Step ID if issue is step-specific */
  stepId?: string;
  /** Issue description */
  message: string;
  /** Suggested fix */
  suggestedFix?: string;
}

/**
 * Result of self-reflection.
 */
export interface ReflectionResult {
  /** Key insights from reflection */
  insights: string[];
  /** Identified issues */
  issues: string[];
  /** Suggested plan adjustments */
  adjustments: PlanAdjustment[];
  /** Updated confidence score */
  confidenceAdjustment: number;
  /** Whether to continue or replan */
  recommendation: 'continue' | 'adjust' | 'replan' | 'abort';
}

/**
 * A suggested adjustment to the plan.
 */
export interface PlanAdjustment {
  /** Type of adjustment */
  type: 'add_step' | 'remove_step' | 'modify_step' | 'reorder';
  /** Target step ID (for modify/remove) */
  targetStepId?: string;
  /** New step data (for add/modify) */
  newStepData?: Partial<PlanStep>;
  /** Reason for adjustment */
  reason: string;
}

/**
 * Current state of plan execution.
 */
export interface ExecutionState {
  /** Plan being executed */
  planId: string;
  /** Current step index */
  currentStepIndex: number;
  /** Completed step IDs */
  completedSteps: string[];
  /** Failed step IDs */
  failedSteps: string[];
  /** Accumulated results */
  results: Map<string, PlanStepResult>;
  /** Total tokens used */
  tokensUsed: number;
  /** Start timestamp */
  startedAt: Date;
  /** Last update timestamp */
  lastUpdatedAt: Date;
}

/**
 * Context for step execution.
 */
export interface StepExecutionContext {
  /** Results from previous steps */
  previousResults: Map<string, PlanStepResult>;
  /** Available tools */
  tools: ITool[];
  /** Conversation context */
  conversationContext?: string;
  /** RAG retrieval function */
  retrieve?: (query: string) => Promise<string[]>;
}

/**
 * Final summary after autonomous loop completion.
 */
export interface ExecutionSummary {
  /** Whether goal was achieved */
  goalAchieved: boolean;
  /** Final confidence score */
  finalConfidence: number;
  /** Total iterations */
  iterations: number;
  /** Total tokens used */
  totalTokensUsed: number;
  /** Total duration in ms */
  totalDurationMs: number;
  /** Key outcomes */
  outcomes: string[];
  /** Final synthesized result */
  finalResult?: unknown;
  /** Any unresolved issues */
  unresolvedIssues: string[];
}

