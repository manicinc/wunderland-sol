/**
 * Project Publisher Service
 * @module lib/write/projectPublisher
 *
 * Publishes writing projects as strands in two formats:
 * - Single combined strand: All chapters concatenated into one markdown file
 * - Folder strand: Project folder with strand.yml and individual chapter files
 */

import { v4 as uuidv4 } from 'uuid'
import { getProject, updateProject } from './projectStore'
import type {
  WritingProject,
  PublishProjectOptions,
  PublishProjectResult,
} from './types'
import { getStoredVaultHandle } from '@/lib/vault/vaultConfig'
import {
  writeVaultFile,
  readVaultFile,
  getVaultDirectory,
} from '@/lib/vault/vaultManager'
import { saveStrand, getStrandByPath } from '@/lib/storage/localCodex'

// ============================================================================
// CONSTANTS
// ============================================================================

const DEFAULT_TARGET_WEAVE = 'weaves/writings'

// ============================================================================
// HELPERS
// ============================================================================

/**
 * Slugify text for URL-safe paths
 */
function slugify(text: string): string {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '')
}

/**
 * Generate YAML frontmatter for a strand
 */
function generateFrontmatter(
  project: WritingProject,
  options: {
    slug: string
    wordCount: number
    chaptersCount: number
  }
): string {
  const lines = ['---']
  lines.push(`id: "${uuidv4()}"`)
  lines.push(`slug: "${options.slug}"`)
  lines.push(`title: "${project.title.replace(/"/g, '\\"')}"`)
  lines.push(`version: "1.0.0"`)
  lines.push(`contentType: "collection"`)

  if (project.description) {
    lines.push(`summary: "${project.description.replace(/"/g, '\\"')}"`)
  }

  if (project.tags && project.tags.length > 0) {
    lines.push(`tags: [${project.tags.map((t) => `"${t}"`).join(', ')}]`)
  }

  lines.push(`taxonomy:`)
  lines.push(`  subjects: ["writing", "${project.type}"]`)

  lines.push(`publishing:`)
  lines.push(`  status: "${project.status === 'complete' ? 'published' : 'draft'}"`)
  lines.push(`  lastUpdated: "${new Date().toISOString()}"`)

  // Custom metadata for writing projects
  lines.push(`writingProject:`)
  lines.push(`  type: "${project.type}"`)
  lines.push(`  wordCount: ${options.wordCount}`)
  if (project.wordGoal) {
    lines.push(`  wordGoal: ${project.wordGoal}`)
  }
  lines.push(`  partsCount: ${project.parts.length}`)
  lines.push(`  chaptersCount: ${options.chaptersCount}`)
  lines.push(`  createdAt: "${project.createdAt}"`)

  lines.push('---')
  return lines.join('\n')
}

/**
 * Generate table of contents from project structure
 */
function generateTableOfContents(
  project: WritingProject,
  options: {
    includeSynopses?: boolean
    includeWordCounts?: boolean
    linkFormat?: 'anchor' | 'file' // 'anchor' for single file, 'file' for folder
  }
): string {
  const lines = ['## Table of Contents', '']

  for (const part of project.parts) {
    // Part heading
    lines.push(`### ${part.title}`)
    if (part.description) {
      lines.push(`*${part.description}*`)
    }
    lines.push('')

    // Chapters
    for (const chapter of part.chapters) {
      const anchor = slugify(chapter.title)
      const link =
        options.linkFormat === 'file' ? `./${anchor}.md` : `#${anchor}`

      let line = `- [${chapter.title}](${link})`

      if (options.includeWordCounts && chapter.wordCount > 0) {
        line += ` (${chapter.wordCount.toLocaleString()} words)`
      }

      lines.push(line)

      if (options.includeSynopses && chapter.synopsis) {
        lines.push(`  > ${chapter.synopsis}`)
      }
    }
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Generate strand.yml schema for folder-strand
 */
function generateStrandYml(
  project: WritingProject,
  options: {
    slug: string
    chapterFiles: string[]
    totalWords: number
  }
): string {
  const lines = [
    `# OpenStrand Schema for: ${project.title}`,
    `# Generated by Quarry Write Mode`,
    '',
    `id: "${uuidv4()}"`,
    `slug: "${options.slug}"`,
    `title: "${project.title.replace(/"/g, '\\"')}"`,
    `version: "1.0.0"`,
    `strandType: "folder"`,
    `contentType: "collection"`,
    '',
  ]

  if (project.description) {
    lines.push(`summary: "${project.description.replace(/"/g, '\\"')}"`)
    lines.push('')
  }

  lines.push(`entryFile: "index.md"`)
  lines.push('')

  // Includes section
  lines.push(`includes:`)
  lines.push(`  content:`)
  for (const file of options.chapterFiles) {
    lines.push(`    - "${file}"`)
  }
  lines.push('')

  // Tags
  if (project.tags && project.tags.length > 0) {
    lines.push(`tags:`)
    for (const tag of project.tags) {
      lines.push(`  - "${tag}"`)
    }
    lines.push('')
  }

  lines.push(`taxonomy:`)
  lines.push(`  subjects:`)
  lines.push(`    - "writing"`)
  lines.push(`    - "${project.type}"`)
  lines.push('')

  // Publishing
  lines.push(`publishing:`)
  lines.push(`  status: "${project.status === 'complete' ? 'published' : 'draft'}"`)
  lines.push(`  lastUpdated: "${new Date().toISOString()}"`)
  lines.push('')

  // Custom metadata
  lines.push(`# Writing Project Metadata`)
  lines.push(`writingProject:`)
  lines.push(`  type: "${project.type}"`)
  lines.push(`  wordCount: ${options.totalWords}`)
  if (project.wordGoal) {
    lines.push(`  wordGoal: ${project.wordGoal}`)
  }
  lines.push(`  partsCount: ${project.parts.length}`)
  lines.push(
    `  chaptersCount: ${project.parts.reduce((sum, p) => sum + p.chapters.length, 0)}`
  )
  lines.push(`  createdAt: "${project.createdAt}"`)

  return lines.join('\n')
}

/**
 * Read chapter content from its strand path
 */
async function readChapterContent(
  strandPath: string,
  vaultHandle: FileSystemDirectoryHandle | null
): Promise<string> {
  // Try to read from vault first
  if (vaultHandle) {
    try {
      const content = await readVaultFile(vaultHandle, strandPath + '.md')
      // Strip frontmatter if present
      return content.replace(/^---[\s\S]*?---\n*/m, '')
    } catch {
      // Fall through to database
    }
  }

  // Try database
  try {
    const strand = await getStrandByPath(strandPath)
    if (strand) {
      return strand.content.replace(/^---[\s\S]*?---\n*/m, '')
    }
  } catch {
    // Content not found
  }

  return ''
}

// ============================================================================
// OPTION A: SINGLE COMBINED STRAND
// ============================================================================

/**
 * Publish project as a single combined markdown file
 */
export async function publishProjectAsStrand(
  options: PublishProjectOptions,
  onProgress?: (progress: number, message: string) => void
): Promise<PublishProjectResult> {
  const startTime = Date.now()
  const warnings: string[] = []

  onProgress?.(5, 'Loading project...')

  // Get project
  const project = getProject(options.projectId)
  if (!project) {
    return {
      success: false,
      totalWords: 0,
      chaptersPublished: 0,
      durationMs: Date.now() - startTime,
      error: 'Project not found',
    }
  }

  // Generate slug
  const slug = options.slug || slugify(project.title)
  const targetWeave = options.targetWeave || DEFAULT_TARGET_WEAVE
  const strandPath = `${targetWeave}/${slug}.md`

  onProgress?.(10, 'Collecting chapter content...')

  // Get vault handle
  const vaultHandle = await getStoredVaultHandle()

  // Collect all chapter content
  const contentSections: string[] = []
  let totalWords = 0
  let chaptersPublished = 0
  const totalChapters = project.parts.reduce(
    (sum, p) => sum + p.chapters.length,
    0
  )

  for (let partIdx = 0; partIdx < project.parts.length; partIdx++) {
    const part = project.parts[partIdx]

    // Add part heading
    contentSections.push(`# ${part.title}`)
    if (part.description) {
      contentSections.push(`*${part.description}*`)
    }
    contentSections.push('')

    for (let chapterIdx = 0; chapterIdx < part.chapters.length; chapterIdx++) {
      const chapter = part.chapters[chapterIdx]
      const chapterNumber =
        project.parts
          .slice(0, partIdx)
          .reduce((sum, p) => sum + p.chapters.length, 0) +
        chapterIdx +
        1
      const progress = 10 + Math.round((chapterNumber / totalChapters) * 60)

      onProgress?.(progress, `Reading chapter: ${chapter.title}...`)

      // Add chapter heading with anchor
      const anchor = slugify(chapter.title)
      contentSections.push(`## ${chapter.title} {#${anchor}}`)
      if (chapter.synopsis) {
        contentSections.push(`> *${chapter.synopsis}*`)
      }
      contentSections.push('')

      // Read chapter content
      const chapterContent = await readChapterContent(
        chapter.strandPath,
        vaultHandle
      )
      if (chapterContent) {
        contentSections.push(chapterContent)
        totalWords += chapter.wordCount
        chaptersPublished++
      } else {
        warnings.push(`Chapter "${chapter.title}" has no content`)
      }

      contentSections.push('')
      contentSections.push('---')
      contentSections.push('')
    }
  }

  onProgress?.(75, 'Generating strand...')

  // Generate TOC
  const toc = generateTableOfContents(project, {
    includeSynopses: options.includeSynopses,
    includeWordCounts: options.includeWordCounts,
    linkFormat: 'anchor',
  })

  // Build complete content
  const frontmatter = generateFrontmatter(project, {
    slug,
    wordCount: totalWords,
    chaptersCount: chaptersPublished,
  })
  const fullContent = [frontmatter, '', toc, '', ...contentSections].join('\n')

  if (options.dryRun) {
    return {
      success: true,
      strandPath,
      strandType: 'file',
      totalWords,
      chaptersPublished,
      durationMs: Date.now() - startTime,
      warnings: warnings.length > 0 ? warnings : undefined,
    }
  }

  onProgress?.(85, 'Writing to vault...')

  // Write to vault
  if (vaultHandle) {
    try {
      await writeVaultFile(vaultHandle, strandPath, fullContent)
    } catch (error) {
      warnings.push(
        `Vault write failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      )
    }
  }

  onProgress?.(90, 'Updating database...')

  // Save to database
  await saveStrand({
    path: strandPath,
    title: project.title,
    content: fullContent,
    frontmatter: frontmatter,
  })

  onProgress?.(95, 'Updating project...')

  // Update project publishing status
  updateProject(options.projectId, {
    publishing: {
      isPublished: true,
      publishedAt: new Date().toISOString(),
      publishedPath: strandPath,
      publishFormat: 'single-strand',
      strandType: 'file',
    },
  })

  onProgress?.(100, 'Complete!')

  return {
    success: true,
    strandPath,
    strandType: 'file',
    totalWords,
    chaptersPublished,
    durationMs: Date.now() - startTime,
    warnings: warnings.length > 0 ? warnings : undefined,
  }
}

// ============================================================================
// OPTION B: FOLDER STRAND
// ============================================================================

/**
 * Publish project as a folder-strand with strand.yml
 */
export async function publishProjectAsFolderStrand(
  options: PublishProjectOptions,
  onProgress?: (progress: number, message: string) => void
): Promise<PublishProjectResult> {
  const startTime = Date.now()
  const warnings: string[] = []

  onProgress?.(5, 'Loading project...')

  // Get project
  const project = getProject(options.projectId)
  if (!project) {
    return {
      success: false,
      totalWords: 0,
      chaptersPublished: 0,
      durationMs: Date.now() - startTime,
      error: 'Project not found',
    }
  }

  // Generate slug and paths
  const slug = options.slug || slugify(project.title)
  const targetWeave = options.targetWeave || DEFAULT_TARGET_WEAVE
  const folderPath = `${targetWeave}/${slug}`

  onProgress?.(10, 'Preparing folder structure...')

  // Get vault handle
  const vaultHandle = await getStoredVaultHandle()
  if (!vaultHandle && !options.dryRun) {
    return {
      success: false,
      totalWords: 0,
      chaptersPublished: 0,
      durationMs: Date.now() - startTime,
      error: 'Vault not configured. Folder-strands require a vault folder.',
    }
  }

  // Collect chapter content and prepare files
  const chapterFiles: string[] = ['index.md']
  const filesToWrite: Array<{ path: string; content: string }> = []
  let totalWords = 0
  let chaptersPublished = 0
  const totalChapters = project.parts.reduce(
    (sum, p) => sum + p.chapters.length,
    0
  )

  // Read all chapters
  for (let partIdx = 0; partIdx < project.parts.length; partIdx++) {
    const part = project.parts[partIdx]

    for (let chapterIdx = 0; chapterIdx < part.chapters.length; chapterIdx++) {
      const chapter = part.chapters[chapterIdx]
      const chapterSlug = slugify(chapter.title)
      const chapterFileName = `${String(partIdx + 1).padStart(2, '0')}-${String(chapterIdx + 1).padStart(2, '0')}-${chapterSlug}.md`

      const chapterNumber =
        project.parts
          .slice(0, partIdx)
          .reduce((sum, p) => sum + p.chapters.length, 0) +
        chapterIdx +
        1
      const progress = 10 + Math.round((chapterNumber / totalChapters) * 50)

      onProgress?.(progress, `Processing chapter: ${chapter.title}...`)

      // Read chapter content
      const chapterContent = await readChapterContent(
        chapter.strandPath,
        vaultHandle
      )

      if (chapterContent) {
        // Build chapter file content
        const chapterFrontmatter = [
          '---',
          `title: "${chapter.title.replace(/"/g, '\\"')}"`,
          `part: "${part.title.replace(/"/g, '\\"')}"`,
          `order: ${partIdx * 100 + chapterIdx}`,
          `wordCount: ${chapter.wordCount}`,
          `status: "${chapter.status}"`,
        ]
        if (chapter.synopsis) {
          chapterFrontmatter.push(
            `synopsis: "${chapter.synopsis.replace(/"/g, '\\"')}"`
          )
        }
        chapterFrontmatter.push('---')

        const fullChapterContent = [
          chapterFrontmatter.join('\n'),
          '',
          `# ${chapter.title}`,
          '',
          chapterContent,
        ].join('\n')

        chapterFiles.push(chapterFileName)
        filesToWrite.push({
          path: `${folderPath}/${chapterFileName}`,
          content: fullChapterContent,
        })

        totalWords += chapter.wordCount
        chaptersPublished++
      } else {
        warnings.push(`Chapter "${chapter.title}" has no content`)
      }
    }
  }

  onProgress?.(65, 'Generating index and schema...')

  // Generate index.md (entry file)
  const indexFrontmatter = generateFrontmatter(project, {
    slug,
    wordCount: totalWords,
    chaptersCount: chaptersPublished,
  })

  const indexContent = [
    indexFrontmatter,
    '',
    `# ${project.title}`,
    '',
    project.description ? `${project.description}\n\n` : '',
    generateTableOfContents(project, {
      includeSynopses: options.includeSynopses,
      includeWordCounts: options.includeWordCounts,
      linkFormat: 'file',
    }),
  ].join('\n')

  filesToWrite.unshift({
    path: `${folderPath}/index.md`,
    content: indexContent,
  })

  // Generate strand.yml
  const strandYml = generateStrandYml(project, {
    slug,
    chapterFiles,
    totalWords,
  })

  filesToWrite.push({
    path: `${folderPath}/strand.yml`,
    content: strandYml,
  })

  if (options.dryRun) {
    return {
      success: true,
      strandPath: folderPath,
      strandType: 'folder',
      totalWords,
      chaptersPublished,
      durationMs: Date.now() - startTime,
      warnings: warnings.length > 0 ? warnings : undefined,
    }
  }

  onProgress?.(75, 'Creating folder structure...')

  // Create folder and write files
  if (vaultHandle) {
    try {
      // Create the folder
      await getVaultDirectory(vaultHandle, folderPath, true)

      // Write all files
      for (let i = 0; i < filesToWrite.length; i++) {
        const file = filesToWrite[i]
        const fileProgress = 75 + Math.round((i / filesToWrite.length) * 15)
        onProgress?.(fileProgress, `Writing: ${file.path.split('/').pop()}...`)

        await writeVaultFile(vaultHandle, file.path, file.content)
      }
    } catch (error) {
      return {
        success: false,
        totalWords,
        chaptersPublished,
        durationMs: Date.now() - startTime,
        error: `Vault write failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      }
    }
  }

  onProgress?.(92, 'Updating database...')

  // Save entry strand to database
  await saveStrand({
    path: `${folderPath}/index.md`,
    title: project.title,
    content: indexContent,
    frontmatter: indexFrontmatter,
  })

  onProgress?.(96, 'Updating project...')

  // Update project publishing status
  updateProject(options.projectId, {
    publishing: {
      isPublished: true,
      publishedAt: new Date().toISOString(),
      publishedPath: folderPath,
      publishFormat: 'folder-strand',
      strandType: 'folder',
    },
  })

  onProgress?.(100, 'Complete!')

  return {
    success: true,
    strandPath: folderPath,
    strandType: 'folder',
    totalWords,
    chaptersPublished,
    durationMs: Date.now() - startTime,
    warnings: warnings.length > 0 ? warnings : undefined,
  }
}

// ============================================================================
// UNIFIED PUBLISH FUNCTION
// ============================================================================

/**
 * Publish a project as a strand (dispatches to appropriate format handler)
 */
export async function publishProject(
  options: PublishProjectOptions,
  onProgress?: (progress: number, message: string) => void
): Promise<PublishProjectResult> {
  if (options.format === 'single-strand') {
    return publishProjectAsStrand(options, onProgress)
  } else {
    return publishProjectAsFolderStrand(options, onProgress)
  }
}
