/**
 * Content Selection Cache Utilities
 * @module lib/generation/contentSelectionCache
 *
 * Provides order-independent cache key generation for multi-strand selections.
 * Ensures that [A, B, C] and [C, A, B] generate the same cache key.
 */

/* ═══════════════════════════════════════════════════════════════════════════
   TYPES
═══════════════════════════════════════════════════════════════════════════ */

export type GenerationType = 'flashcards' | 'glossary' | 'quiz'

export interface SelectionCacheParams {
  /** Array of strand IDs or paths */
  strandIds: string[]
  /** Type of content being generated */
  generationType: GenerationType
  /** Whether LLM is used for generation */
  useLLM: boolean
  /** Optional difficulty level */
  difficulty?: string
}

export interface CacheKeyInfo {
  /** The generated cache key */
  key: string
  /** Sorted strand IDs used to generate the key */
  sortedIds: string[]
  /** Number of strands in selection */
  count: number
  /** Hash portion of the key */
  hash: string
}

/* ═══════════════════════════════════════════════════════════════════════════
   HASHING
═══════════════════════════════════════════════════════════════════════════ */

/**
 * DJB2 hash algorithm - fast and good distribution
 */
function djb2Hash(str: string): string {
  let hash = 5381
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) + hash) ^ str.charCodeAt(i)
  }
  // Convert to unsigned 32-bit and then to hex
  return (hash >>> 0).toString(16).padStart(8, '0')
}

/* ═══════════════════════════════════════════════════════════════════════════
   CACHE KEY GENERATION
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Generate an order-independent cache key from a strand selection.
 *
 * The key is generated by:
 * 1. Sorting strand IDs alphabetically (order independence)
 * 2. Creating a canonical JSON representation
 * 3. Hashing the canonical string
 * 4. Prefixing with generation type and method
 *
 * @example
 * // These produce the same key:
 * generateSelectionCacheKey({ strandIds: ['a', 'b', 'c'], generationType: 'flashcards', useLLM: false })
 * generateSelectionCacheKey({ strandIds: ['c', 'a', 'b'], generationType: 'flashcards', useLLM: false })
 */
export function generateSelectionCacheKey(params: SelectionCacheParams): string {
  const { strandIds, generationType, useLLM, difficulty } = params

  // Sort IDs alphabetically for order independence
  const sortedIds = [...strandIds].sort()

  // Create canonical string representation
  const canonical = JSON.stringify({
    ids: sortedIds,
    type: generationType,
    llm: useLLM,
    difficulty: difficulty || 'mixed',
  })

  // Generate hash
  const hash = djb2Hash(canonical)

  // Build key with prefix for readability
  const method = useLLM ? 'llm' : 'nlp'
  const prefix = sortedIds.length > 1 ? 'multi' : 'single'

  return `${generationType}_${method}_${prefix}_${hash}`
}

/**
 * Generate cache key with additional info for debugging/display
 */
export function generateSelectionCacheKeyWithInfo(params: SelectionCacheParams): CacheKeyInfo {
  const { strandIds } = params
  const sortedIds = [...strandIds].sort()
  const key = generateSelectionCacheKey(params)
  const hash = key.split('_').pop() || ''

  return {
    key,
    sortedIds,
    count: sortedIds.length,
    hash,
  }
}

/* ═══════════════════════════════════════════════════════════════════════════
   SELECTION COMPARISON
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Check if two selections are equivalent (ignoring order)
 */
export function selectionsEqual(a: string[], b: string[]): boolean {
  if (a.length !== b.length) return false
  const sortedA = [...a].sort()
  const sortedB = [...b].sort()
  return sortedA.every((id, i) => id === sortedB[i])
}

/**
 * Check if selection A is a subset of selection B
 */
export function isSubsetOf(a: string[], b: string[]): boolean {
  const setB = new Set(b)
  return a.every(id => setB.has(id))
}

/**
 * Get the difference between two selections (ids in A but not in B)
 */
export function selectionDifference(a: string[], b: string[]): string[] {
  const setB = new Set(b)
  return a.filter(id => !setB.has(id))
}

/**
 * Merge two selections, removing duplicates
 */
export function mergeSelections(a: string[], b: string[]): string[] {
  return [...new Set([...a, ...b])]
}

/* ═══════════════════════════════════════════════════════════════════════════
   SELECTION SERIALIZATION
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Serialize selection for storage (order-independent)
 */
export function serializeSelection(strandIds: string[]): string {
  return [...strandIds].sort().join('|')
}

/**
 * Deserialize selection from storage
 */
export function deserializeSelection(serialized: string): string[] {
  return serialized.split('|').filter(Boolean)
}

/**
 * Create a short display name for a selection
 */
export function getSelectionDisplayName(strandIds: string[], maxItems = 2): string {
  const count = strandIds.length
  if (count === 0) return 'No selection'
  if (count === 1) return strandIds[0]

  const visible = strandIds.slice(0, maxItems)
  const remaining = count - maxItems

  if (remaining > 0) {
    return `${visible.join(', ')} +${remaining} more`
  }
  return visible.join(', ')
}

/* ═══════════════════════════════════════════════════════════════════════════
   CACHE INVALIDATION HELPERS
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Generate all possible cache keys for a selection across all generation types
 */
export function getAllCacheKeysForSelection(
  strandIds: string[],
  useLLM: boolean
): Record<GenerationType, string> {
  return {
    flashcards: generateSelectionCacheKey({ strandIds, generationType: 'flashcards', useLLM }),
    glossary: generateSelectionCacheKey({ strandIds, generationType: 'glossary', useLLM }),
    quiz: generateSelectionCacheKey({ strandIds, generationType: 'quiz', useLLM }),
  }
}

/**
 * Check if a cache key matches a given selection
 */
export function cacheKeyMatchesSelection(
  cacheKey: string,
  strandIds: string[],
  generationType: GenerationType,
  useLLM: boolean
): boolean {
  const expectedKey = generateSelectionCacheKey({ strandIds, generationType, useLLM })
  return cacheKey === expectedKey
}
