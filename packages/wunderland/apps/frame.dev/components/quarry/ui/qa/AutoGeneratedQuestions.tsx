/**
 * Auto-Generated Questions - AI-powered question generation for documents
 * @module codex/ui/AutoGeneratedQuestions
 * 
 * @remarks
 * Analyzes document content and generates relevant questions using NLP.
 * Styled like Roam Research backlinks - as linked reference cards.
 * 
 * Question categories:
 * - Comprehension: "What is X?"
 * - Application: "How can X be used?"
 * - Analysis: "Why does X relate to Y?"
 * - Exploration: "What are alternatives to X?"
 */

'use client'

import React, { useEffect, useState, useMemo, useCallback } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { 
  Sparkles, HelpCircle, Lightbulb, BookOpen, Link2, 
  ChevronRight, RefreshCw, Brain, Compass, Layers,
  MessageCircle, Zap, Target, ArrowRight
} from 'lucide-react'
import { extractKeywords, extractEntities, suggestTags } from '@/lib/nlp'

interface AutoGeneratedQuestionsProps {
  /** Document content to analyze */
  content: string
  /** Document title */
  title?: string
  /** Document tags */
  tags?: string[]
  /** Callback when a question is selected */
  onSelectQuestion?: (question: string) => void
  /** Current theme */
  theme?: string
  /** Maximum questions to display */
  maxQuestions?: number
  /** Show refresh button */
  showRefresh?: boolean
  /** Compact mode */
  compact?: boolean
}

interface GeneratedQuestion {
  id: string
  text: string
  type: 'comprehension' | 'application' | 'analysis' | 'exploration'
  confidence: number
  source: 'keyword' | 'entity' | 'tag' | 'structure'
  icon: React.ElementType
  relatedTerm?: string
}

// Question templates by type
const QUESTION_TEMPLATES = {
  comprehension: [
    "What is {term}?",
    "How would you define {term}?",
    "What are the key characteristics of {term}?",
    "Can you explain {term} in simple terms?",
  ],
  application: [
    "How can {term} be applied in practice?",
    "What are the use cases for {term}?",
    "When should you use {term}?",
    "How do you implement {term}?",
  ],
  analysis: [
    "Why is {term} important?",
    "How does {term} compare to alternatives?",
    "What are the advantages of {term}?",
    "What are the limitations of {term}?",
  ],
  exploration: [
    "What are related concepts to {term}?",
    "How has {term} evolved over time?",
    "What are best practices for {term}?",
    "What's the future of {term}?",
  ],
}

const TYPE_CONFIG = {
  comprehension: { 
    icon: BookOpen, 
    label: 'Understanding',
    color: 'cyan',
    bgLight: 'bg-cyan-50',
    bgDark: 'bg-cyan-900/20',
    borderLight: 'border-cyan-200',
    borderDark: 'border-cyan-800',
    textLight: 'text-cyan-700',
    textDark: 'text-cyan-300',
  },
  application: { 
    icon: Target, 
    label: 'Application',
    color: 'emerald',
    bgLight: 'bg-emerald-50',
    bgDark: 'bg-emerald-900/20',
    borderLight: 'border-emerald-200',
    borderDark: 'border-emerald-800',
    textLight: 'text-emerald-700',
    textDark: 'text-emerald-300',
  },
  analysis: { 
    icon: Brain, 
    label: 'Analysis',
    color: 'purple',
    bgLight: 'bg-purple-50',
    bgDark: 'bg-purple-900/20',
    borderLight: 'border-purple-200',
    borderDark: 'border-purple-800',
    textLight: 'text-purple-700',
    textDark: 'text-purple-300',
  },
  exploration: { 
    icon: Compass, 
    label: 'Exploration',
    color: 'amber',
    bgLight: 'bg-amber-50',
    bgDark: 'bg-amber-900/20',
    borderLight: 'border-amber-200',
    borderDark: 'border-amber-800',
    textLight: 'text-amber-700',
    textDark: 'text-amber-300',
  },
}

/**
 * Generate questions from content analysis
 */
function generateQuestionsFromContent(
  content: string,
  title?: string,
  tags?: string[],
  maxQuestions: number = 6
): GeneratedQuestion[] {
  if (!content || content.length < 50) return []
  
  const questions: GeneratedQuestion[] = []
  const usedTerms = new Set<string>()
  
  // Extract keywords and entities
  const keywords = extractKeywords(content).slice(0, 10)
  const entities = extractEntities(content)
  const suggestedTagsFromContent = suggestTags(content).slice(0, 5)
  
  // Priority terms: combine unique terms from different sources
  const priorityTerms: { term: string; source: GeneratedQuestion['source']; weight: number }[] = []
  
  // Add title as high-priority term
  if (title && title.length > 3) {
    priorityTerms.push({ term: title, source: 'structure', weight: 10 })
  }
  
  // Add tags
  if (tags) {
    tags.forEach(tag => {
      if (!usedTerms.has(tag.toLowerCase())) {
        priorityTerms.push({ term: tag, source: 'tag', weight: 8 })
        usedTerms.add(tag.toLowerCase())
      }
    })
  }
  
  // Add suggested tags from content
  suggestedTagsFromContent.forEach(tag => {
    if (!usedTerms.has(tag.toLowerCase())) {
      priorityTerms.push({ term: tag, source: 'tag', weight: 7 })
      usedTerms.add(tag.toLowerCase())
    }
  })
  
  // Add entities
  const allEntities = [
    ...entities.technologies,
    ...entities.concepts,
    ...entities.languages,
    ...entities.frameworks,
  ]
  allEntities.forEach(entity => {
    if (!usedTerms.has(entity.toLowerCase()) && entity.length > 2) {
      priorityTerms.push({ term: entity, source: 'entity', weight: 6 })
      usedTerms.add(entity.toLowerCase())
    }
  })
  
  // Add keywords
  keywords.forEach(kw => {
    if (!usedTerms.has(kw.word.toLowerCase()) && kw.word.length > 3) {
      priorityTerms.push({ term: kw.word, source: 'keyword', weight: kw.score * 5 })
      usedTerms.add(kw.word.toLowerCase())
    }
  })
  
  // Sort by weight and take top terms
  priorityTerms.sort((a, b) => b.weight - a.weight)
  const topTerms = priorityTerms.slice(0, Math.ceil(maxQuestions * 1.5))
  
  // Generate questions for each term
  const types: GeneratedQuestion['type'][] = ['comprehension', 'application', 'analysis', 'exploration']
  let typeIndex = 0
  
  topTerms.forEach((termInfo, idx) => {
    if (questions.length >= maxQuestions) return
    
    const type = types[typeIndex % types.length]
    const templates = QUESTION_TEMPLATES[type]
    const template = templates[Math.floor(Math.random() * templates.length)]
    const questionText = template.replace('{term}', termInfo.term)
    
    questions.push({
      id: `q-${idx}`,
      text: questionText,
      type,
      confidence: Math.min(0.95, termInfo.weight / 10),
      source: termInfo.source,
      icon: TYPE_CONFIG[type].icon,
      relatedTerm: termInfo.term,
    })
    
    typeIndex++
  })
  
  return questions
}

/**
 * Auto-generated questions component styled like Roam backlinks
 */
export default function AutoGeneratedQuestions({
  content,
  title,
  tags,
  onSelectQuestion,
  theme = 'light',
  maxQuestions = 6,
  showRefresh = true,
  compact = false,
}: AutoGeneratedQuestionsProps) {
  const [questions, setQuestions] = useState<GeneratedQuestion[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const [selectedType, setSelectedType] = useState<GeneratedQuestion['type'] | 'all'>('all')
  
  const isDark = theme?.includes('dark')
  
  // Generate questions when content changes
  useEffect(() => {
    if (content && content.length > 50) {
      setIsGenerating(true)
      // Simulate async generation (NLP can be heavy)
      const timer = setTimeout(() => {
        const generated = generateQuestionsFromContent(content, title, tags, maxQuestions)
        setQuestions(generated)
        setIsGenerating(false)
      }, 300)
      return () => clearTimeout(timer)
    } else {
      setQuestions([])
    }
  }, [content, title, tags, maxQuestions])
  
  // Regenerate questions
  const handleRefresh = useCallback(() => {
    setIsGenerating(true)
    setTimeout(() => {
      const generated = generateQuestionsFromContent(content, title, tags, maxQuestions)
      setQuestions(generated)
      setIsGenerating(false)
    }, 300)
  }, [content, title, tags, maxQuestions])
  
  // Filter by type
  const filteredQuestions = useMemo(() => {
    if (selectedType === 'all') return questions
    return questions.filter(q => q.type === selectedType)
  }, [questions, selectedType])
  
  // Group by type for stats
  const questionsByType = useMemo(() => {
    const grouped: Record<GeneratedQuestion['type'], number> = {
      comprehension: 0,
      application: 0,
      analysis: 0,
      exploration: 0,
    }
    questions.forEach(q => grouped[q.type]++)
    return grouped
  }, [questions])
  
  if (!content || content.length < 50) return null
  
  return (
    <div className={`
      mt-6 rounded-xl border overflow-hidden
      ${isDark ? 'bg-zinc-900/50 border-zinc-800' : 'bg-white border-zinc-200'}
    `}>
      {/* Header - Roam-style linked references header */}
      <div className={`
        px-4 py-3 border-b flex items-center justify-between
        ${isDark ? 'border-zinc-800 bg-zinc-800/30' : 'border-zinc-100 bg-zinc-50'}
      `}>
        <div className="flex items-center gap-3">
          <div className={`
            p-1.5 rounded-lg
            ${isDark ? 'bg-cyan-900/30' : 'bg-cyan-100'}
          `}>
            <MessageCircle className={`w-4 h-4 ${isDark ? 'text-cyan-400' : 'text-cyan-600'}`} />
          </div>
          <div>
            <h3 className={`text-sm font-semibold ${isDark ? 'text-zinc-200' : 'text-zinc-800'}`}>
              Questions this strand may answer
            </h3>
            <p className={`text-xs ${isDark ? 'text-zinc-500' : 'text-zinc-400'}`}>
              {questions.length} questions generated • Click to explore
            </p>
          </div>
        </div>
        
        {showRefresh && (
          <button
            onClick={handleRefresh}
            disabled={isGenerating}
            className={`
              p-2 rounded-lg transition-colors
              ${isDark ? 'hover:bg-zinc-700' : 'hover:bg-zinc-100'}
              ${isGenerating ? 'animate-spin' : ''}
            `}
            title="Regenerate questions"
          >
            <RefreshCw className={`w-4 h-4 ${isDark ? 'text-zinc-400' : 'text-zinc-500'}`} />
          </button>
        )}
      </div>
      
      {/* Type filters */}
      {!compact && (
        <div className={`
          px-4 py-2 flex items-center gap-2 overflow-x-auto
          ${isDark ? 'border-b border-zinc-800' : 'border-b border-zinc-100'}
        `}>
          <button
            onClick={() => setSelectedType('all')}
            className={`
              px-3 py-1 rounded-full text-xs font-medium whitespace-nowrap transition-all
              ${selectedType === 'all'
                ? isDark 
                  ? 'bg-zinc-700 text-zinc-100' 
                  : 'bg-zinc-200 text-zinc-800'
                : isDark 
                  ? 'text-zinc-400 hover:bg-zinc-800' 
                  : 'text-zinc-500 hover:bg-zinc-100'
              }
            `}
          >
            All ({questions.length})
          </button>
          {Object.entries(TYPE_CONFIG).map(([type, config]) => {
            const count = questionsByType[type as GeneratedQuestion['type']]
            if (count === 0) return null
            const Icon = config.icon
            return (
              <button
                key={type}
                onClick={() => setSelectedType(type as GeneratedQuestion['type'])}
                className={`
                  flex items-center gap-1.5 px-3 py-1 rounded-full text-xs font-medium whitespace-nowrap transition-all
                  ${selectedType === type
                    ? isDark 
                      ? `${config.bgDark} ${config.textDark}` 
                      : `${config.bgLight} ${config.textLight}`
                    : isDark 
                      ? 'text-zinc-400 hover:bg-zinc-800' 
                      : 'text-zinc-500 hover:bg-zinc-100'
                  }
                `}
              >
                <Icon className="w-3 h-3" />
                {config.label} ({count})
              </button>
            )
          })}
        </div>
      )}
      
      {/* Questions list - Roam-style linked references */}
      <div className={`p-4 ${compact ? 'space-y-2' : 'space-y-3'}`}>
        <AnimatePresence mode="popLayout">
          {isGenerating ? (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="flex items-center justify-center py-8"
            >
              <Sparkles className={`w-5 h-5 animate-pulse ${isDark ? 'text-cyan-400' : 'text-cyan-500'}`} />
              <span className={`ml-2 text-sm ${isDark ? 'text-zinc-400' : 'text-zinc-500'}`}>
                Generating questions...
              </span>
            </motion.div>
          ) : filteredQuestions.length === 0 ? (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className={`text-center py-6 ${isDark ? 'text-zinc-500' : 'text-zinc-400'}`}
            >
              <HelpCircle className="w-8 h-8 mx-auto mb-2 opacity-50" />
              <p className="text-sm">No questions found for this filter</p>
            </motion.div>
          ) : (
            filteredQuestions.map((question, idx) => {
              const config = TYPE_CONFIG[question.type]
              const Icon = config.icon
              
              return (
                <motion.button
                  key={question.id}
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -10 }}
                  transition={{ delay: idx * 0.05 }}
                  onClick={() => onSelectQuestion?.(question.text)}
                  className={`
                    w-full text-left group
                    flex items-start gap-3 p-3 rounded-lg border
                    transition-all duration-200
                    hover:shadow-md
                    ${isDark 
                      ? `${config.bgDark} ${config.borderDark} hover:border-${config.color}-600` 
                      : `${config.bgLight} ${config.borderLight} hover:border-${config.color}-400`
                    }
                  `}
                >
                  {/* Icon */}
                  <div className={`
                    p-2 rounded-lg shrink-0
                    ${isDark ? 'bg-zinc-800/50' : 'bg-white/70'}
                  `}>
                    <Icon className={`w-4 h-4 ${isDark ? config.textDark : config.textLight}`} />
                  </div>
                  
                  {/* Content */}
                  <div className="flex-1 min-w-0">
                    <p className={`text-sm font-medium leading-relaxed ${isDark ? 'text-zinc-200' : 'text-zinc-800'}`}>
                      {question.text}
                    </p>
                    
                    {/* Meta info */}
                    <div className={`flex items-center gap-2 mt-1.5 text-xs ${isDark ? 'text-zinc-500' : 'text-zinc-400'}`}>
                      {question.relatedTerm && (
                        <span className={`
                          px-1.5 py-0.5 rounded
                          ${isDark ? 'bg-zinc-800' : 'bg-zinc-100'}
                        `}>
                          {question.relatedTerm}
                        </span>
                      )}
                      <span className="opacity-60">•</span>
                      <span>{config.label}</span>
                    </div>
                  </div>
                  
                  {/* Arrow on hover */}
                  <ArrowRight className={`
                    w-4 h-4 shrink-0 mt-3 opacity-0 group-hover:opacity-100
                    transition-opacity ${isDark ? 'text-zinc-400' : 'text-zinc-500'}
                  `} />
                </motion.button>
              )
            })
          )}
        </AnimatePresence>
      </div>
      
      {/* Footer hint */}
      {!compact && questions.length > 0 && (
        <div className={`
          px-4 py-2 text-xs flex items-center gap-2
          ${isDark ? 'text-zinc-500 border-t border-zinc-800' : 'text-zinc-400 border-t border-zinc-100'}
        `}>
          <Lightbulb className="w-3 h-3" />
          <span>Questions auto-generated from document content using NLP</span>
        </div>
      )}
    </div>
  )
}






