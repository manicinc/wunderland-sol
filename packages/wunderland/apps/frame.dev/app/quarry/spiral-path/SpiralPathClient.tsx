/**
 * Spiral Path Client - Learning Pathway Visualization
 * @module codex/spiral-path/SpiralPathClient
 * 
 * @description
 * Client-side component for the Spiral Path feature.
 * Uses real GitHub data from the Codex repository.
 * 
 * @remarks
 * This component fetches data from:
 * - GitHub repository tree (via useGithubTree hook)
 * - codex-index.json (for metadata, prerequisites, tags)
 * - Individual strand files (for relationship extraction)
 * 
 * @architecture
 * - Tree View: Hierarchical outline using OutlineTableOfContents patterns
 * - Graph View: D3 force-directed graph using SpiralKnowledgeGraph patterns
 * - Path Planner: Dijkstra's algorithm on prerequisite graph
 * - Skill Input: User mastery levels for personalized paths
 */

'use client'

import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import Link from 'next/link'
import { useRouter, useSearchParams } from 'next/navigation'
import * as d3 from 'd3'
import {
  GitBranch,
  TreePine,
  Network,
  Filter,
  ChevronRight,
  ChevronDown,
  ChevronLeft,
  FileText,
  Folder,
  Target,
  Sparkles,
  ArrowRight,
  ArrowLeft,
  RotateCcw,
  ZoomIn,
  ZoomOut,
  Layers,
  BookOpen,
  GraduationCap,
  Sliders,
  X,
  Info,
  Eye,
  EyeOff,
  Map as MapIcon,
  Route,
  Play,
  CheckCircle,
  CheckCircle2,
  Circle,
  AlertCircle,
  Zap,
  Search,
  Download,
  Copy,
  FileJson,
  Image,
  FileDown,
  Terminal,
  HelpCircle,
  Menu,
  PanelLeftClose,
  PanelRightClose,
  Maximize2,
  Minimize2,
} from 'lucide-react'
import QuarryPageLayout from '@/components/quarry/QuarryPageLayout'
import AmbienceRightSidebar from '@/components/quarry/ui/sidebar/AmbienceRightSidebar'
import SpiralPathLeftSidebar from '@/components/quarry/ui/sidebar/SpiralPathLeftSidebar'
import { useGithubTree } from '@/components/quarry/hooks/useGithubTree'
import { API_ENDPOINTS, REPO_CONFIG, LEVEL_STYLES } from '@/components/quarry/constants'
import { parseWikiMetadata, isMarkdownFile } from '@/components/quarry/utils'
import type { KnowledgeTreeNode, StrandMetadata, TagIndexEntry } from '@/components/quarry/types'
import { parseTags as parseTagsUtil } from '@/lib/utils'

/* ═══════════════════════════════════════════════════════════════════════════
   TYPES
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Strand node in the learning path graph
 */
interface PathNode {
  /** Unique identifier (file path) */
  id: string
  /** Display title */
  title: string
  /** File path in repository */
  path: string
  /** Node type in hierarchy */
  type: 'weave' | 'loom' | 'strand'
  /** Difficulty level */
  difficulty: 'beginner' | 'intermediate' | 'advanced' | 'expert' | 'unknown'
  /** Tags from metadata */
  tags: string[]
  /** Skills required (learning prerequisites) */
  skills: string[]
  /** Parent loom/weave */
  parent?: string
  /** Direct prerequisites (other strand paths) */
  prerequisites: string[]
  /** References (related content) */
  references: string[]
  /** User's mastery level (0-100) */
  mastery: number
  /** Estimated reading time in minutes */
  estimatedTime?: number
  /** Depth in hierarchy */
  depth: number
  /** Summary from codex-index.json */
  summary?: string
}

/**
 * Edge in the learning path graph
 */
interface PathEdge {
  source: string
  target: string
  type: 'prerequisite' | 'reference' | 'parent' | 'sibling'
  weight: number
}

/**
 * User skill level input
 */
interface SkillLevel {
  /** Tag or topic name */
  name: string
  /** Mastery level (0-100) */
  level: number
  /** How confident the user is in this rating */
  confidence: 'low' | 'medium' | 'high'
}

/**
 * Codex index entry from codex-index.json
 */
interface CodexIndexEntry {
  path: string
  metadata?: {
    title?: string
    summary?: string
    difficulty?: string
    tags?: string | string[]
    skills?: string[]  // Learning prerequisites
    taxonomy?: {
      subjects?: string[]
      topics?: string[]
    }
    relationships?: {
      prerequisites?: string[]
      references?: string[]
    }
    timeEstimates?: {
      reading?: number
      total?: number
    }
    autoGenerated?: {
      lastIndexed?: string
      skills?: string[]  // Auto-detected skills
    }
  }
}

/**
 * View mode for the visualization
 */
type ViewMode = 'tree' | 'graph' | 'info' | 'ascii'

/**
 * Filter state
 */
interface FilterState {
  weave: string | null
  loom: string | null
  tags: string[]
  difficulty: string | null
  showCompleted: boolean
  searchQuery: string
}

/* ═══════════════════════════════════════════════════════════════════════════
   UTILITIES
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Parse difficulty from various formats
 */
function parseDifficulty(diff: unknown): PathNode['difficulty'] {
  if (!diff) return 'unknown'
  if (typeof diff === 'string') {
    const lower = diff.toLowerCase()
    if (lower.includes('beginner') || lower.includes('easy')) return 'beginner'
    if (lower.includes('intermediate') || lower.includes('medium')) return 'intermediate'
    if (lower.includes('advanced') || lower.includes('hard')) return 'advanced'
    if (lower.includes('expert')) return 'expert'
  }
  if (typeof diff === 'object' && diff !== null && 'overall' in diff) {
    return parseDifficulty((diff as { overall: unknown }).overall)
  }
  return 'unknown'
}

/**
 * Parse tags from various formats (uses centralized utility with min length filter)
 */
function parseTags(tags: unknown): string[] {
  return parseTagsUtil(tags, { lowercase: false })
}

/**
 * Get color for difficulty level
 */
function getDifficultyColor(difficulty: PathNode['difficulty']): string {
  switch (difficulty) {
    case 'beginner': return '#10B981' // emerald
    case 'intermediate': return '#F59E0B' // amber
    case 'advanced': return '#EF4444' // red
    case 'expert': return '#8B5CF6' // violet
    default: return '#6B7280' // gray
  }
}

/**
 * Get mastery color (green gradient)
 */
function getMasteryColor(mastery: number): string {
  if (mastery >= 80) return '#10B981'
  if (mastery >= 60) return '#34D399'
  if (mastery >= 40) return '#FBBF24'
  if (mastery >= 20) return '#F97316'
  return '#6B7280'
}

/**
 * Dijkstra's algorithm for shortest learning path
 * Uses all edge types: prerequisites, references, parent, and sibling relationships
 */
function findShortestPath(
  nodes: PathNode[],
  edges: PathEdge[],
  startId: string,
  endId: string
): string[] {
  const nodeMap = new Map<string, PathNode>()
  nodes.forEach(n => nodeMap.set(n.id, n))
  const adjacency = new Map<string, Array<{ target: string; weight: number; type: string }>>()
  
  // Helper to add bidirectional edge
  const addEdge = (from: string, to: string, weight: number, type: string) => {
    if (!adjacency.has(from)) adjacency.set(from, [])
    adjacency.get(from)!.push({ target: to, weight, type })
  }
  
  // Build adjacency list from all edge types
  edges.forEach(edge => {
    const baseWeight = edge.weight || 1
    
    if (edge.type === 'prerequisite') {
      // If A requires B, we can go from B to A (learn prereq first)
      addEdge(edge.target, edge.source, baseWeight, 'prerequisite')
      // Also allow reverse (though more expensive)
      addEdge(edge.source, edge.target, baseWeight * 2, 'prerequisite-reverse')
    } else if (edge.type === 'reference') {
      // References are bidirectional with same weight
      addEdge(edge.source, edge.target, baseWeight, 'reference')
      addEdge(edge.target, edge.source, baseWeight, 'reference')
    } else if (edge.type === 'parent') {
      // Parent edges - can traverse both ways
      addEdge(edge.source, edge.target, baseWeight, 'parent')
      addEdge(edge.target, edge.source, baseWeight * 0.5, 'child')
    }
  })
  
  // Create sibling edges (nodes with same parent)
  const parentGroups = new Map<string, string[]>()
  nodes.forEach(n => {
    if (n.parent) {
      if (!parentGroups.has(n.parent)) parentGroups.set(n.parent, [])
      parentGroups.get(n.parent)!.push(n.id)
    }
  })
  parentGroups.forEach(siblings => {
    for (let i = 0; i < siblings.length; i++) {
      for (let j = i + 1; j < siblings.length; j++) {
        addEdge(siblings[i], siblings[j], 0.3, 'sibling')
        addEdge(siblings[j], siblings[i], 0.3, 'sibling')
      }
    }
  })
  
  // If still no edges, create edges based on folder proximity
  if (adjacency.size === 0) {
    // Group by folder (parent path)
    const folderGroups = new Map<string, string[]>()
    nodes.forEach(n => {
      const folder = n.path.substring(0, n.path.lastIndexOf('/'))
      if (!folderGroups.has(folder)) folderGroups.set(folder, [])
      folderGroups.get(folder)!.push(n.id)
    })
    
    // Connect nodes in same folder
    folderGroups.forEach(nodeIds => {
      for (let i = 0; i < nodeIds.length; i++) {
        for (let j = i + 1; j < nodeIds.length; j++) {
          addEdge(nodeIds[i], nodeIds[j], 0.5, 'folder-sibling')
          addEdge(nodeIds[j], nodeIds[i], 0.5, 'folder-sibling')
        }
      }
    })
    
    // Connect folders to each other (weaker connection)
    const folders = Array.from(folderGroups.keys())
    for (let i = 0; i < folders.length; i++) {
      for (let j = i + 1; j < folders.length; j++) {
        const nodesA = folderGroups.get(folders[i])!
        const nodesB = folderGroups.get(folders[j])!
        // Connect first node of each folder
        if (nodesA.length > 0 && nodesB.length > 0) {
          addEdge(nodesA[0], nodesB[0], 1.5, 'folder-bridge')
          addEdge(nodesB[0], nodesA[0], 1.5, 'folder-bridge')
        }
      }
    }
  }
  
  // Standard Dijkstra
  const distances = new Map<string, number>()
  const previous = new Map<string, string | null>()
  const visited = new Set<string>()
  const pq: Array<{ id: string; distance: number }> = []
  
  nodes.forEach(n => {
    distances.set(n.id, n.id === startId ? 0 : Infinity)
    previous.set(n.id, null)
  })
  
  pq.push({ id: startId, distance: 0 })
  
  while (pq.length > 0) {
    pq.sort((a, b) => a.distance - b.distance)
    const current = pq.shift()!
    
    if (visited.has(current.id)) continue
    visited.add(current.id)
    
    if (current.id === endId) break
    
    const neighbors = adjacency.get(current.id) || []
    for (const { target, weight } of neighbors) {
      if (visited.has(target)) continue
      
      const node = nodeMap.get(target)
      // Adjust weight based on user mastery (higher mastery = lower cost)
      const masteryFactor = node ? (100 - node.mastery) / 100 : 1
      const adjustedWeight = weight * masteryFactor
      
      const newDist = distances.get(current.id)! + adjustedWeight
      if (newDist < distances.get(target)!) {
        distances.set(target, newDist)
        previous.set(target, current.id)
        pq.push({ id: target, distance: newDist })
      }
    }
  }
  
  // Reconstruct path
  const path: string[] = []
  let current: string | null = endId
  while (current !== null) {
    path.unshift(current)
    current = previous.get(current) ?? null
  }
  
  // Return empty if no path found
  if (path[0] !== startId) return []
  return path
}

/* ═══════════════════════════════════════════════════════════════════════════
   SUB-COMPONENTS
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Tree node component for hierarchical view
 */
function TreeNode({
  node,
  depth,
  expanded,
  onToggle,
  onSelect,
  selectedId,
  pathHighlight,
  children,
}: {
  node: PathNode
  depth: number
  expanded: boolean
  onToggle: () => void
  onSelect: () => void
  selectedId: string | null
  pathHighlight: Set<string>
  children?: React.ReactNode
}) {
  const isSelected = node.id === selectedId
  const isInPath = pathHighlight.has(node.id)
  const hasChildren = !!children
  
  return (
    <div className="select-none">
      <motion.div
        initial={false}
        animate={{
          backgroundColor: isSelected 
            ? 'rgba(16, 185, 129, 0.15)' 
            : isInPath 
              ? 'rgba(251, 191, 36, 0.1)' 
              : 'transparent',
        }}
        className={`
          flex items-center gap-2 px-3 py-2.5 md:px-2 md:py-1.5 rounded-lg cursor-pointer
          transition-colors hover:bg-zinc-100 dark:hover:bg-zinc-800/50 touch-manipulation
          ${isInPath ? 'ring-2 ring-amber-400/50' : ''}
          min-h-[44px] md:min-h-0
        `}
        style={{ paddingLeft: `${depth * 12 + 12}px` }}
        onClick={onSelect}
      >
        {/* Expand/collapse toggle */}
        {hasChildren ? (
          <button
            onClick={(e) => { e.stopPropagation(); onToggle() }}
            className="p-1.5 md:p-0.5 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded touch-manipulation min-w-[28px] min-h-[28px] md:min-w-0 md:min-h-0 flex items-center justify-center"
          >
            {expanded ? (
              <ChevronDown className="w-4 h-4 text-zinc-500" />
            ) : (
              <ChevronRight className="w-4 h-4 text-zinc-500" />
            )}
          </button>
        ) : (
          <span className="w-7 md:w-5" />
        )}
        
        {/* Icon */}
        {node.type === 'strand' ? (
          <FileText className="w-4 h-4 text-emerald-500 flex-shrink-0" />
        ) : node.type === 'loom' ? (
          <Folder className="w-4 h-4 text-cyan-500 flex-shrink-0" />
        ) : (
          <Layers className="w-4 h-4 text-amber-500 flex-shrink-0" />
        )}
        
        {/* Title */}
        <span className={`
          text-sm truncate flex-1
          ${isSelected ? 'font-semibold text-emerald-700 dark:text-emerald-300' : 'text-zinc-700 dark:text-zinc-300'}
        `}>
          {node.title}
        </span>
        
        {/* Mastery indicator */}
        {node.type === 'strand' && (
          <div className="flex items-center gap-1.5">
            {/* Difficulty badge */}
            <span
              className="px-1.5 py-0.5 text-[10px] font-medium rounded"
              style={{ 
                backgroundColor: `${getDifficultyColor(node.difficulty)}20`,
                color: getDifficultyColor(node.difficulty),
              }}
            >
              {node.difficulty}
            </span>
            
            {/* Mastery ring */}
            <div
              className="w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold"
              style={{
                background: `conic-gradient(${getMasteryColor(node.mastery)} ${node.mastery * 3.6}deg, #e5e7eb ${node.mastery * 3.6}deg)`,
              }}
            >
              <div className="w-3.5 h-3.5 rounded-full bg-white dark:bg-zinc-900 flex items-center justify-center">
                {node.mastery >= 80 ? (
                  <CheckCircle2 className="w-3 h-3 text-emerald-500" />
                ) : node.mastery > 0 ? (
                  <span className="text-[8px]">{node.mastery}</span>
                ) : (
                  <Circle className="w-2.5 h-2.5 text-zinc-300" />
                )}
              </div>
            </div>
          </div>
        )}
      </motion.div>
      
      {/* Children */}
      <AnimatePresence>
        {expanded && children && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.2 }}
            className="overflow-hidden"
          >
            {children}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

/**
 * Skill level input component
 */
function SkillInput({
  skill,
  onChange,
  onRemove,
}: {
  skill: SkillLevel
  onChange: (skill: SkillLevel) => void
  onRemove: () => void
}) {
  return (
    <div className="flex items-center gap-3 p-3 bg-zinc-50 dark:bg-zinc-800/50 rounded-lg">
      <div className="flex-1">
        <div className="flex items-center justify-between mb-1">
          <span className="text-sm font-medium text-zinc-700 dark:text-zinc-300">
            {skill.name}
          </span>
          <span className="text-xs text-zinc-500">{skill.level}%</span>
        </div>
        <input
          type="range"
          min="0"
          max="100"
          value={skill.level}
          onChange={(e) => onChange({ ...skill, level: parseInt(e.target.value) })}
          className="w-full h-2 bg-zinc-200 dark:bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-emerald-500"
        />
      </div>
      <button
        onClick={onRemove}
        className="p-1 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded"
      >
        <X className="w-4 h-4 text-zinc-400" />
      </button>
    </div>
  )
}

/**
 * Legend component for the graph view
 */
function GraphLegend({ visible, onToggle }: { visible: boolean; onToggle: () => void }) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className="absolute top-4 left-4 z-10"
    >
      <button
        onClick={onToggle}
        className="flex items-center gap-2 px-3 py-2 bg-white dark:bg-zinc-900 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700"
      >
        <MapIcon className="w-4 h-4" />
        <span className="text-sm font-medium">Legend</span>
        {visible ? <ChevronDown className="w-4 h-4" /> : <ChevronRight className="w-4 h-4" />}
      </button>
      
      <AnimatePresence>
        {visible && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="mt-2 p-4 bg-white dark:bg-zinc-900 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700 space-y-3"
          >
            <div className="text-xs font-semibold text-zinc-500 uppercase tracking-wider">Node Types</div>
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 rounded-full bg-amber-500" />
                <span className="text-sm">Weave</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 rounded-full bg-cyan-500" />
                <span className="text-sm">Loom</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 rounded-full bg-emerald-500" />
                <span className="text-sm">Strand</span>
              </div>
            </div>
            
            <div className="border-t border-zinc-200 dark:border-zinc-700 pt-3">
              <div className="text-xs font-semibold text-zinc-500 uppercase tracking-wider mb-2">Difficulty</div>
              <div className="space-y-1">
                {(['beginner', 'intermediate', 'advanced', 'expert'] as const).map(d => (
                  <div key={d} className="flex items-center gap-2">
                    <div 
                      className="w-2 h-2 rounded-full" 
                      style={{ backgroundColor: getDifficultyColor(d) }}
                    />
                    <span className="text-xs capitalize">{d}</span>
                  </div>
                ))}
              </div>
            </div>
            
            <div className="border-t border-zinc-200 dark:border-zinc-700 pt-3">
              <div className="text-xs font-semibold text-zinc-500 uppercase tracking-wider mb-2">Edge Types</div>
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <div className="w-4 h-0.5 bg-rose-500" />
                  <span className="text-xs">Prerequisite</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-4 h-0.5 bg-emerald-500 opacity-50" style={{ borderStyle: 'dashed', borderWidth: 1 }} />
                  <span className="text-xs">Reference</span>
                </div>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  )
}

/* ═══════════════════════════════════════════════════════════════════════════
   MAIN COMPONENT
═══════════════════════════════════════════════════════════════════════════ */

/**
 * Spiral Path Client Component
 * 
 * @description
 * Main client-side component for the learning pathway visualization.
 * Fetches real data from GitHub and renders interactive tree/graph views.
 */
export default function SpiralPathClient() {
  const router = useRouter()
  const searchParams = useSearchParams()

  // ─────────────────────────────────────────────────────────────────────────
  // Mobile Detection & Responsive State
  // ─────────────────────────────────────────────────────────────────────────

  const [isMobile, setIsMobile] = useState(false)
  const [isTablet, setIsTablet] = useState(false)
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)
  const [mobileDetailOpen, setMobileDetailOpen] = useState(false)

  // Detect screen size on mount and resize
  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < 768)
      setIsTablet(window.innerWidth >= 768 && window.innerWidth < 1024)
    }
    checkScreenSize()
    window.addEventListener('resize', checkScreenSize)
    return () => window.removeEventListener('resize', checkScreenSize)
  }, [])

  // Close mobile panels when switching to desktop
  useEffect(() => {
    if (!isMobile && !isTablet) {
      setMobileMenuOpen(false)
      setMobileDetailOpen(false)
    }
  }, [isMobile, isTablet])

  // ─────────────────────────────────────────────────────────────────────────
  // State
  // ─────────────────────────────────────────────────────────────────────────

  const [viewMode, setViewMode] = useState<ViewMode>('tree')
  const [selectedNode, setSelectedNode] = useState<PathNode | null>(null)
  // Initialize from URL params: ?strand=path/to/file.md&as=goal (or as=start)
  const initialStrand = searchParams.get('strand')
  const strandRole = searchParams.get('as') || 'goal' // default to goal
  const [pathStart, setPathStart] = useState<string | null>(
    strandRole === 'start' && initialStrand ? initialStrand : null
  )
  const [pathEnd, setPathEnd] = useState<string | null>(
    strandRole === 'goal' && initialStrand ? initialStrand : null
  )
  const [calculatedPath, setCalculatedPath] = useState<string[]>([])
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set(['weaves']))
  const [showLegend, setShowLegend] = useState(true)
  const [showFilters, setShowFilters] = useState(true)
  const [showSkillPanel, setShowSkillPanel] = useState(false)
  
  const [filters, setFilters] = useState<FilterState>({
    weave: null,
    loom: null,
    tags: [],
    difficulty: null,
    showCompleted: true,
    searchQuery: '',
  })
  
  const [skills, setSkills] = useState<SkillLevel[]>([])
  const [newSkillName, setNewSkillName] = useState('')
  
  // Graph nodes and edges (built from tree data)
  const [pathNodes, setPathNodes] = useState<PathNode[]>([])
  const [pathEdges, setPathEdges] = useState<PathEdge[]>([])
  
  // Index data
  const [codexIndex, setCodexIndex] = useState<Map<string, CodexIndexEntry['metadata']>>(new Map())
  const [tagsIndex, setTagsIndex] = useState<TagIndexEntry[]>([])
  const [weavesIndex, setWeavesIndex] = useState<string[]>([])
  const [loomsIndex, setLoomsIndex] = useState<string[]>([])
  
  // SVG ref for D3 graph
  const svgRef = useRef<SVGSVGElement>(null)
  const [zoom, setZoom] = useState(1)
  
  // ─────────────────────────────────────────────────────────────────────────
  // Data fetching - GitHub tree
  // ─────────────────────────────────────────────────────────────────────────
  
  const {
    tree: knowledgeTree,
    loading: treeLoading,
    error: treeError,
    totalStrands,
    totalWeaves,
  } = useGithubTree()
  
  // ─────────────────────────────────────────────────────────────────────────
  // Data fetching - Codex index
  // ─────────────────────────────────────────────────────────────────────────
  
  useEffect(() => {
    const fetchIndex = async () => {
      try {
        const indexUrl = API_ENDPOINTS.raw('codex-index.json')
        const response = await fetch(indexUrl)
        if (!response.ok) return
        
        const payload = await response.json() as CodexIndexEntry[]
        const map = new Map<string, CodexIndexEntry['metadata']>()
        const tags = new Map<string, { count: number; paths: string[] }>()
        const weaves = new Set<string>()
        const looms = new Set<string>()
        
        payload.forEach(entry => {
          if (!entry.path) return
          map.set(entry.path, entry.metadata)
          
          // Extract weaves and looms from paths
          const parts = entry.path.split('/')
          if (parts[0] === 'weaves' && parts.length > 1) {
            weaves.add(parts[1])
            if (parts.length > 3) {
              looms.add(parts.slice(0, 4).join('/'))
            }
          }
          
          // Extract tags
          const entryTags = parseTags(entry.metadata?.tags)
          entryTags.forEach(tag => {
            const existing = tags.get(tag) || { count: 0, paths: [] }
            existing.count++
            existing.paths.push(entry.path)
            tags.set(tag, existing)
          })
        })
        
        setCodexIndex(map)
        setTagsIndex(Array.from(tags.entries()).map(([name, data]) => ({
          name,
          count: data.count,
          paths: data.paths,
        })).sort((a, b) => b.count - a.count))
        setWeavesIndex(Array.from(weaves).sort())
        setLoomsIndex(Array.from(looms).sort())
      } catch (err) {
        console.warn('Failed to fetch codex-index.json:', err)
      }
    }
    
    fetchIndex()
  }, [])
  
  // ─────────────────────────────────────────────────────────────────────────
  // Build path graph from tree data
  // ─────────────────────────────────────────────────────────────────────────
  
  useEffect(() => {
    if (knowledgeTree.length === 0) return
    
    const nodes: PathNode[] = []
    const edges: PathEdge[] = []
    
    /**
     * Recursively process tree nodes
     */
    function processNode(node: KnowledgeTreeNode, parentPath: string | undefined, depth: number) {
      const indexMeta = codexIndex.get(node.path)
      
      // Determine type
      let type: PathNode['type'] = 'strand'
      if (node.level === 'weave') type = 'weave'
      else if (node.level === 'loom') type = 'loom'
      else if (node.type === 'dir') type = 'loom'
      
      // Only include strands (files) in the graph for path planning
      if (node.type === 'file' && isMarkdownFile(node.name)) {
        // Extract skills from metadata (frontmatter + auto-generated)
        const metaSkills = indexMeta?.skills || []
        const autoSkills = (indexMeta?.autoGenerated as { skills?: string[] })?.skills || []
        const combinedSkills = [...new Set([...metaSkills, ...autoSkills])]
        
        const pathNode: PathNode = {
          id: node.path,
          title: indexMeta?.title || node.name.replace(/\.md$/, '').replace(/-/g, ' '),
          path: node.path,
          type: 'strand',
          difficulty: parseDifficulty(indexMeta?.difficulty),
          tags: [
            ...parseTags(indexMeta?.tags),
            ...(indexMeta?.taxonomy?.topics || []),
            ...(indexMeta?.taxonomy?.subjects || []),
          ],
          skills: combinedSkills,  // Learning prerequisites
          parent: parentPath,
          prerequisites: indexMeta?.relationships?.prerequisites || [],
          references: indexMeta?.relationships?.references || [],
          mastery: 0, // Will be updated based on user skills
          estimatedTime: indexMeta?.timeEstimates?.reading || indexMeta?.timeEstimates?.total,
          depth,
          summary: indexMeta?.summary,
        }
        
        nodes.push(pathNode)
        
        // Create prerequisite edges
        pathNode.prerequisites.forEach(prereq => {
          edges.push({
            source: pathNode.id,
            target: prereq,
            type: 'prerequisite',
            weight: 1,
          })
        })
        
        // Create reference edges
        pathNode.references.forEach(ref => {
          edges.push({
            source: pathNode.id,
            target: ref,
            type: 'reference',
            weight: 0.5,
          })
        })
        
        // Create parent edge
        if (parentPath) {
          edges.push({
            source: pathNode.id,
            target: parentPath,
            type: 'parent',
            weight: 0.2,
          })
        }
      }
      
      // Process children
      if (node.children) {
        node.children.forEach(child => {
          processNode(child, node.path, depth + 1)
        })
      }
    }
    
    knowledgeTree.forEach(node => processNode(node, undefined, 0))
    
    // Update mastery based on user skills (check both tags and skills array)
    nodes.forEach(node => {
      const matchingFromTags = skills.filter(skill =>
        node.tags.some(tag => tag.toLowerCase().includes(skill.name.toLowerCase()))
      )
      const matchingFromSkills = skills.filter(skill =>
        node.skills.some(nodeSkill => nodeSkill.toLowerCase().includes(skill.name.toLowerCase()))
      )
      const allMatching = [...new Set([...matchingFromTags, ...matchingFromSkills])]

      if (allMatching.length > 0) {
        node.mastery = Math.round(
          allMatching.reduce((sum, s) => sum + s.level, 0) / allMatching.length
        )
      }
    })

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD IMPLICIT EDGES - enables path finding even without explicit prereqs
    // ═══════════════════════════════════════════════════════════════════════

    // Helper: Calculate tag similarity between two nodes (Jaccard index)
    const tagSimilarity = (a: PathNode, b: PathNode): number => {
      if (a.tags.length === 0 || b.tags.length === 0) return 0
      const setA = new Set(a.tags.map(t => t.toLowerCase()))
      const setB = new Set(b.tags.map(t => t.toLowerCase()))
      const intersection = [...setA].filter(t => setB.has(t)).length
      const union = new Set([...setA, ...setB]).size
      return union > 0 ? intersection / union : 0
    }

    // Helper: Get difficulty level as number for progression
    const difficultyLevel = (d: PathNode['difficulty']): number => {
      switch (d) {
        case 'beginner': return 1
        case 'intermediate': return 2
        case 'advanced': return 3
        case 'expert': return 4
        default: return 2 // unknown defaults to intermediate
      }
    }

    // Helper: Get parent folder path
    const getParentFolder = (path: string): string => {
      const parts = path.split('/')
      parts.pop() // Remove filename
      return parts.join('/')
    }

    // Group nodes by parent folder for proximity edges
    const folderGroups = new Map<string, PathNode[]>()
    nodes.forEach(node => {
      const folder = getParentFolder(node.path)
      if (!folderGroups.has(folder)) folderGroups.set(folder, [])
      folderGroups.get(folder)!.push(node)
    })

    // Create existing edge set to avoid duplicates
    const existingEdges = new Set(edges.map(e => `${e.source}|${e.target}`))
    const addEdge = (source: string, target: string, type: PathEdge['type'], weight: number) => {
      const key = `${source}|${target}`
      const reverseKey = `${target}|${source}`
      if (!existingEdges.has(key) && !existingEdges.has(reverseKey) && source !== target) {
        edges.push({ source, target, type, weight })
        existingEdges.add(key)
      }
    }

    // 1. Folder proximity edges (same loom/weave = related content)
    folderGroups.forEach(siblings => {
      // Sort by difficulty for natural progression within folder
      const sorted = [...siblings].sort((a, b) => difficultyLevel(a.difficulty) - difficultyLevel(b.difficulty))
      for (let i = 0; i < sorted.length - 1; i++) {
        addEdge(sorted[i].id, sorted[i + 1].id, 'sibling', 0.4)
      }
    })

    // 2. Tag similarity edges (strands sharing significant tags)
    const TAG_SIMILARITY_THRESHOLD = 0.3 // At least 30% tag overlap
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const similarity = tagSimilarity(nodes[i], nodes[j])
        if (similarity >= TAG_SIMILARITY_THRESHOLD) {
          // Weight inversely proportional to similarity (higher similarity = easier connection)
          const weight = 1 - (similarity * 0.5) // 0.5-1.0 range
          addEdge(nodes[i].id, nodes[j].id, 'reference', weight)
        }
      }
    }

    // 3. Difficulty progression edges within same weave
    // Group by weave first
    const weaveGroups = new Map<string, PathNode[]>()
    nodes.forEach(node => {
      const parts = node.path.split('/')
      const weave = parts[0] === 'weaves' && parts[1] ? parts[1] : 'root'
      if (!weaveGroups.has(weave)) weaveGroups.set(weave, [])
      weaveGroups.get(weave)!.push(node)
    })

    weaveGroups.forEach(weaveNodes => {
      // Group by difficulty
      const byDifficulty = new Map<number, PathNode[]>()
      weaveNodes.forEach(node => {
        const level = difficultyLevel(node.difficulty)
        if (!byDifficulty.has(level)) byDifficulty.set(level, [])
        byDifficulty.get(level)!.push(node)
      })

      // Connect difficulty levels (beginner → intermediate → advanced → expert)
      const levels = Array.from(byDifficulty.keys()).sort((a, b) => a - b)
      for (let i = 0; i < levels.length - 1; i++) {
        const currentLevel = byDifficulty.get(levels[i])!
        const nextLevel = byDifficulty.get(levels[i + 1])!
        // Connect each node at current level to nodes at next level with shared tags
        currentLevel.forEach(curr => {
          nextLevel.forEach(next => {
            const sim = tagSimilarity(curr, next)
            if (sim > 0.1) { // Even slight tag overlap is enough for progression
              addEdge(curr.id, next.id, 'reference', 0.6)
            }
          })
        })
      }
    })

    console.log(`[SpiralPath] Built ${edges.length} edges for ${nodes.length} nodes`)

    setPathNodes(nodes)
    setPathEdges(edges)
  }, [knowledgeTree, codexIndex, skills])
  
  // ─────────────────────────────────────────────────────────────────────────
  // Filtered nodes
  // ─────────────────────────────────────────────────────────────────────────
  
  const filteredNodes = useMemo(() => {
    return pathNodes.filter(node => {
      // Filter by weave
      if (filters.weave && !node.path.startsWith(`weaves/${filters.weave}/`)) return false
      
      // Filter by loom
      if (filters.loom && !node.path.startsWith(filters.loom)) return false
      
      // Filter by difficulty (include 'unknown' strands in all filters so content without metadata is visible)
      if (filters.difficulty && node.difficulty !== filters.difficulty && node.difficulty !== 'unknown') return false
      
      // Filter by tags
      if (filters.tags.length > 0) {
        const hasMatchingTag = filters.tags.some(tag =>
          node.tags.some(t => t.toLowerCase() === tag.toLowerCase())
        )
        if (!hasMatchingTag) return false
      }
      
      // Filter by completion
      if (!filters.showCompleted && node.mastery >= 80) return false
      
      // Filter by search query
      if (filters.searchQuery) {
        const query = filters.searchQuery.toLowerCase()
        const matches = 
          node.title.toLowerCase().includes(query) ||
          node.path.toLowerCase().includes(query) ||
          node.tags.some(t => t.toLowerCase().includes(query)) ||
          (node.summary?.toLowerCase().includes(query) ?? false)
        if (!matches) return false
      }
      
      return true
    })
  }, [pathNodes, filters])
  
  // ─────────────────────────────────────────────────────────────────────────
  // Path calculation
  // ─────────────────────────────────────────────────────────────────────────
  
  useEffect(() => {
    if (pathStart && pathEnd && pathNodes.length > 0) {
      const path = findShortestPath(pathNodes, pathEdges, pathStart, pathEnd)
      setCalculatedPath(path)
    } else {
      setCalculatedPath([])
    }
  }, [pathStart, pathEnd, pathNodes, pathEdges])
  
  const pathHighlightSet = useMemo(() => new Set(calculatedPath), [calculatedPath])
  
  // ─────────────────────────────────────────────────────────────────────────
  // Tree structure for tree view
  // ─────────────────────────────────────────────────────────────────────────
  
  const treeStructure = useMemo(() => {
    // Build hierarchical structure from filtered nodes
    const nodeMap = new Map<string, PathNode & { children: PathNode[] }>()
    
    // First pass: create entries with empty children
    filteredNodes.forEach(node => {
      nodeMap.set(node.id, { ...node, children: [] })
    })
    
    // Build tree by grouping by parent directories
    const roots: Array<PathNode & { children: PathNode[] }> = []
    
    filteredNodes.forEach(node => {
      const parts = node.path.split('/')
      parts.pop() // Remove filename
      const parentPath = parts.join('/')
      
      // For now, just return flat list grouped by weave
      roots.push(nodeMap.get(node.id)!)
    })
    
    return roots
  }, [filteredNodes])
  
  // ─────────────────────────────────────────────────────────────────────────
  // D3 Graph Rendering
  // ─────────────────────────────────────────────────────────────────────────
  
  useEffect(() => {
    if (viewMode !== 'graph' || !svgRef.current || filteredNodes.length === 0) return
    
    const width = svgRef.current.clientWidth || 1200
    const height = svgRef.current.clientHeight || 800
    
    // Clear previous
    d3.select(svgRef.current).selectAll('*').remove()
    
    const svg = d3.select(svgRef.current)
      .attr('viewBox', [0, 0, width, height])
      .style('touch-action', 'none') // Enable touch gestures
      .style('user-select', 'none') // Prevent text selection on drag

    const g = svg.append('g')

    // Zoom behavior with touch support
    const zoomBehavior = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.2, 4])
      .touchable(() => true) // Enable touch zoom/pan
      .filter((event) => {
        // Allow all touch events and mouse events (except right-click)
        if (event.type === 'touchstart' || event.type === 'touchmove') return true
        return !event.ctrlKey && event.button === 0
      })
      .on('zoom', (event) => {
        g.attr('transform', event.transform)
        setZoom(event.transform.k)
      })

    svg.call(zoomBehavior)

    // Double-tap to reset zoom on mobile
    let lastTap = 0
    svg.on('touchend', (event) => {
      const currentTime = new Date().getTime()
      const tapLength = currentTime - lastTap
      if (tapLength < 300 && tapLength > 0) {
        // Double tap detected - reset zoom
        svg.transition()
          .duration(300)
          .call(zoomBehavior.transform, d3.zoomIdentity)
        event.preventDefault()
      }
      lastTap = currentTime
    })
    
    // Prepare data for D3
    const nodeData = filteredNodes.map(n => ({
      ...n,
      x: width / 2,
      y: height / 2,
    }))
    
    const nodeIds = new Set(nodeData.map(n => n.id))
    const linkData = pathEdges.filter(e => 
      nodeIds.has(e.source) && nodeIds.has(e.target)
    ).map(e => ({
      ...e,
      source: e.source,
      target: e.target,
    }))
    
    // Create force simulation
    const simulation = d3.forceSimulation(nodeData as d3.SimulationNodeDatum[])
      .force('link', d3.forceLink(linkData)
        .id((d: any) => d.id)
        .distance(100)
        .strength(0.5)
      )
      .force('charge', d3.forceManyBody().strength(-200))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(30))
    
    // Draw links
    const link = g.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(linkData)
      .join('line')
      .attr('stroke', d => d.type === 'prerequisite' ? '#F43F5E' : '#10B981')
      .attr('stroke-width', d => d.type === 'prerequisite' ? 2 : 1)
      .attr('stroke-opacity', d => d.type === 'prerequisite' ? 0.8 : 0.4)
      .attr('stroke-dasharray', d => d.type === 'reference' ? '5,5' : 'none')
    
    // Draw nodes
    const node = g.append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(nodeData)
      .join('g')
      .attr('cursor', 'pointer')
      .call(d3.drag<SVGGElement, any>()
        .on('start', (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart()
          d.fx = d.x
          d.fy = d.y
        })
        .on('drag', (event, d) => {
          d.fx = event.x
          d.fy = event.y
        })
        .on('end', (event, d) => {
          if (!event.active) simulation.alphaTarget(0)
          d.fx = null
          d.fy = null
        }) as any
      )
    
    // Node circles
    node.append('circle')
      .attr('r', d => pathHighlightSet.has(d.id) ? 12 : 8)
      .attr('fill', d => getDifficultyColor(d.difficulty))
      .attr('stroke', d => {
        if (d.id === selectedNode?.id) return '#EC4899'
        if (pathHighlightSet.has(d.id)) return '#FBBF24'
        return '#fff'
      })
      .attr('stroke-width', d => {
        if (d.id === selectedNode?.id || pathHighlightSet.has(d.id)) return 3
        return 1.5
      })
    
    // Mastery ring
    node.append('circle')
      .attr('r', d => pathHighlightSet.has(d.id) ? 16 : 12)
      .attr('fill', 'none')
      .attr('stroke', d => getMasteryColor(d.mastery))
      .attr('stroke-width', 3)
      .attr('stroke-dasharray', d => `${d.mastery * 0.75} 75`)
      .attr('transform', 'rotate(-90)')
    
    // Labels
    node.append('text')
      .text(d => d.title.length > 20 ? d.title.slice(0, 20) + '...' : d.title)
      .attr('x', 20)
      .attr('y', 4)
      .attr('font-size', 11)
      .attr('fill', '#374151')
      .style('pointer-events', 'none')
    
    // Click handler
    node.on('click', (event, d) => {
      event.stopPropagation()
      setSelectedNode(d as PathNode)
    })
    
    // Tooltip
    node.append('title')
      .text(d => `${d.title}\n${d.difficulty} • ${d.mastery}% mastery`)
    
    // Simulation tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y)
      
      node.attr('transform', (d: any) => `translate(${d.x},${d.y})`)
    })
    
    return () => {
      simulation.stop()
    }
  }, [viewMode, filteredNodes, pathEdges, selectedNode, pathHighlightSet])
  
  // ─────────────────────────────────────────────────────────────────────────
  // Handlers
  // ─────────────────────────────────────────────────────────────────────────
  
  const handleAddSkill = useCallback(() => {
    if (!newSkillName.trim()) return
    setSkills(prev => [...prev, { name: newSkillName.trim(), level: 50, confidence: 'medium' }])
    setNewSkillName('')
  }, [newSkillName])
  
  const handleToggleExpand = useCallback((nodeId: string) => {
    setExpandedNodes(prev => {
      const next = new Set(prev)
      if (next.has(nodeId)) next.delete(nodeId)
      else next.add(nodeId)
      return next
    })
  }, [])
  
  const handleNavigateToStrand = useCallback((path: string) => {
    // Use clean SEO-friendly URL
    let cleanPath = path.replace(/\.md$/, '')
    
    // For README files, navigate to the parent folder (folder-strand pattern)
    if (cleanPath.endsWith('/README') || cleanPath.endsWith('/readme')) {
      cleanPath = cleanPath.replace(/\/README$/i, '')
    }
    // Handle standalone README at root
    if (cleanPath === 'README' || cleanPath === 'readme') {
      cleanPath = ''
    }
    
    router.push(`/quarry/${cleanPath}`)
  }, [router])
  
  const handleSetAsStart = useCallback((nodeId: string) => {
    setPathStart(nodeId)
  }, [])
  
  const handleSetAsEnd = useCallback((nodeId: string) => {
    setPathEnd(nodeId)
  }, [])

  const handleClearPath = useCallback(() => {
    setPathStart(null)
    setPathEnd(null)
    setCalculatedPath([])
  }, [])

  // Export state
  const [exportModalOpen, setExportModalOpen] = useState(false)

  const handleExportPath = useCallback(() => {
    setExportModalOpen(true)
  }, [])

  // Generate export data
  const generateExportData = useCallback(() => {
    const pathNodesData = calculatedPath.map((id, i) => {
      const node = pathNodes.find(n => n.id === id)
      return {
        order: i + 1,
        id,
        title: node?.title || id,
        path: node?.path || id,
        difficulty: node?.difficulty || 'unknown',
        estimatedTime: node?.estimatedTime || 5,
        summary: node?.summary,
        tags: node?.tags || [],
      }
    })

    const startNode = pathNodes.find(n => n.id === pathStart)
    const goalNode = pathNodes.find(n => n.id === pathEnd)

    return {
      version: '1.0',
      generated: new Date().toISOString(),
      algorithm: 'dijkstra',
      start: { id: pathStart || '', title: startNode?.title || '' },
      goal: { id: pathEnd || '', title: goalNode?.title || '' },
      steps: pathNodesData,
      totalTime: pathNodesData.reduce((sum, n) => sum + n.estimatedTime, 0),
      totalSteps: pathNodesData.length,
    }
  }, [calculatedPath, pathNodes, pathStart, pathEnd])

  // Export handlers
  const exportAsJSON = useCallback(() => {
    const data = generateExportData()
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `learning-path-${new Date().toISOString().split('T')[0]}.json`
    a.click()
    URL.revokeObjectURL(url)
    setExportModalOpen(false)
  }, [generateExportData])

  const exportAsText = useCallback(() => {
    const data = generateExportData()
    let text = `LEARNING PATH: ${data.goal.title}\n`
    text += `Generated: ${new Date().toLocaleDateString()}\n`
    text += `Total Steps: ${data.totalSteps} | Estimated Time: ~${data.totalTime} minutes\n`
    text += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n`

    data.steps.forEach((step, i) => {
      const marker = i === 0 ? '▶ START' : i === data.steps.length - 1 ? '◆ GOAL' : `  Step ${step.order}`
      text += `${marker}: ${step.title}\n`
      text += `   Path: ${step.path}\n`
      text += `   Difficulty: ${step.difficulty} | Time: ~${step.estimatedTime} min\n`
      if (step.summary) text += `   Summary: ${step.summary}\n`
      if (step.tags.length > 0) text += `   Tags: ${step.tags.join(', ')}\n`
      text += '\n'
    })

    text += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`
    text += `Generated by Quarry Codex Spiral Path\n`

    const blob = new Blob([text], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `learning-path-${new Date().toISOString().split('T')[0]}.txt`
    a.click()
    URL.revokeObjectURL(url)
    setExportModalOpen(false)
  }, [generateExportData])

  const exportAsASCII = useCallback(() => {
    const data = generateExportData()
    let ascii = `\n`
    ascii += `┌${'─'.repeat(50)}┐\n`
    ascii += `│${'LEARNING PATH'.padStart(31).padEnd(50)}│\n`
    ascii += `│${'━'.repeat(50)}│\n`
    ascii += `│${`  ${data.start.title} → ${data.goal.title}`.padEnd(50).slice(0, 50)}│\n`
    ascii += `│${`  ${data.totalSteps} steps • ~${data.totalTime} minutes`.padEnd(50)}│\n`
    ascii += `└${'─'.repeat(50)}┘\n\n`

    data.steps.forEach((step, i) => {
      const isFirst = i === 0
      const isLast = i === data.steps.length - 1
      const label = isFirst ? '← START' : isLast ? '← GOAL' : ''

      ascii += `    ┌${'─'.repeat(30)}┐\n`
      ascii += `    │ ${String(step.order).padStart(2)}. ${step.title.slice(0, 24).padEnd(24)} │ ${label}\n`
      ascii += `    │    [${step.difficulty.padEnd(12)}]       │\n`
      ascii += `    └${'─'.repeat(15)}┬${'─'.repeat(14)}┘\n`

      if (!isLast) {
        ascii += `                 │\n`
        ascii += `                 ▼\n`
      }
    })

    ascii += `\n\nGenerated by Quarry Codex Spiral Path\n`

    // Copy to clipboard and download
    navigator.clipboard.writeText(ascii)
    const blob = new Blob([ascii], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `learning-path-ascii-${new Date().toISOString().split('T')[0]}.txt`
    a.click()
    URL.revokeObjectURL(url)
    setExportModalOpen(false)
  }, [generateExportData])

  const copyToClipboard = useCallback(async () => {
    const data = generateExportData()
    await navigator.clipboard.writeText(JSON.stringify(data, null, 2))
    setExportModalOpen(false)
  }, [generateExportData])

  // PNG Export - capture SVG graph as image
  const exportAsPNG = useCallback(async () => {
    if (!svgRef.current) {
      alert('Please switch to Graph view to export as PNG')
      return
    }

    try {
      const svg = svgRef.current
      const svgData = new XMLSerializer().serializeToString(svg)
      const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' })
      const svgUrl = URL.createObjectURL(svgBlob)

      const img = new window.Image()
      img.onload = () => {
        const canvas = document.createElement('canvas')
        const scale = 2 // Higher resolution
        canvas.width = svg.clientWidth * scale
        canvas.height = svg.clientHeight * scale

        const ctx = canvas.getContext('2d')
        if (!ctx) return

        // White background
        ctx.fillStyle = '#ffffff'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.scale(scale, scale)
        ctx.drawImage(img, 0, 0)

        canvas.toBlob((blob) => {
          if (!blob) return
          const url = URL.createObjectURL(blob)
          const a = document.createElement('a')
          a.href = url
          a.download = `learning-path-graph-${new Date().toISOString().split('T')[0]}.png`
          a.click()
          URL.revokeObjectURL(url)
          URL.revokeObjectURL(svgUrl)
        }, 'image/png')
      }
      img.src = svgUrl
      setExportModalOpen(false)
    } catch (error) {
      console.error('Failed to export PNG:', error)
      alert('Failed to export PNG. Please try again.')
    }
  }, [])

  // PDF Export - generate full learning guide with markdown content
  const exportAsPDF = useCallback(async () => {
    const data = generateExportData()

    // Create a new window with printable content
    const printWindow = window.open('', '_blank')
    if (!printWindow) {
      alert('Please allow popups to export PDF')
      return
    }

    // Build HTML content for the PDF
    let html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Learning Path: ${data.goal.title}</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #1a1a1a;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    .header {
      text-align: center;
      padding-bottom: 30px;
      border-bottom: 2px solid #e5e5e5;
      margin-bottom: 30px;
    }
    .header h1 { font-size: 28px; color: #0a0a0a; margin-bottom: 8px; }
    .header .subtitle { color: #666; font-size: 14px; }
    .meta {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 16px;
      font-size: 13px;
      color: #888;
    }
    .step {
      margin: 24px 0;
      padding: 20px;
      background: #fafafa;
      border-radius: 12px;
      border-left: 4px solid #10b981;
      page-break-inside: avoid;
    }
    .step.start { border-left-color: #10b981; }
    .step.goal { border-left-color: #f59e0b; }
    .step.middle { border-left-color: #6366f1; }
    .step-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .step-number {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #10b981;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }
    .step.goal .step-number { background: #f59e0b; }
    .step.middle .step-number { background: #6366f1; }
    .step-title { font-size: 18px; font-weight: 600; }
    .step-meta {
      display: flex;
      gap: 12px;
      font-size: 12px;
      color: #666;
      margin-bottom: 12px;
    }
    .step-meta span {
      padding: 2px 8px;
      background: #e5e5e5;
      border-radius: 4px;
    }
    .step-path { font-size: 11px; color: #888; font-family: monospace; }
    .step-summary { margin-top: 12px; color: #444; }
    .tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 12px; }
    .tag {
      padding: 2px 8px;
      background: #dbeafe;
      color: #2563eb;
      border-radius: 4px;
      font-size: 11px;
    }
    .footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #e5e5e5;
      text-align: center;
      font-size: 12px;
      color: #888;
    }
    @media print {
      body { padding: 20px; }
      .step { break-inside: avoid; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>📚 Learning Path</h1>
    <div class="subtitle">${data.start.title} → ${data.goal.title}</div>
    <div class="meta">
      <span>📊 ${data.totalSteps} Steps</span>
      <span>⏱️ ~${data.totalTime} minutes</span>
      <span>📅 ${new Date().toLocaleDateString()}</span>
    </div>
  </div>
`

    // Add each step
    data.steps.forEach((step, i) => {
      const isFirst = i === 0
      const isLast = i === data.steps.length - 1
      const stepClass = isFirst ? 'start' : isLast ? 'goal' : 'middle'
      const label = isFirst ? '▶ START' : isLast ? '◆ GOAL' : ''

      html += `
  <div class="step ${stepClass}">
    <div class="step-header">
      <div class="step-number">${step.order}</div>
      <div class="step-title">${step.title} ${label}</div>
    </div>
    <div class="step-meta">
      <span>📈 ${step.difficulty}</span>
      <span>⏱️ ~${step.estimatedTime} min</span>
    </div>
    <div class="step-path">${step.path}</div>
    ${step.summary ? `<div class="step-summary">${step.summary}</div>` : ''}
    ${step.tags.length > 0 ? `
    <div class="tags">
      ${step.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
    </div>
    ` : ''}
  </div>
`
    })

    html += `
  <div class="footer">
    <p>Generated by Quarry Codex Spiral Path</p>
    <p>Algorithm: Dijkstra's Shortest Path with weighted edges</p>
  </div>
</body>
</html>
`

    printWindow.document.write(html)
    printWindow.document.close()

    // Trigger print dialog after content loads
    printWindow.onload = () => {
      printWindow.print()
    }

    setExportModalOpen(false)
  }, [generateExportData])

  // ─────────────────────────────────────────────────────────────────────────
  // Render
  // ─────────────────────────────────────────────────────────────────────────
  
  // Calculate progress stats for sidebar
  const completedStrands = Object.values(strandMastery).filter(m => m >= 3).length
  const totalStrandsCount = flatNodes.filter(n => n.type === 'strand').length

  return (
    <QuarryPageLayout
      showRightPanel={true}
      rightPanelContent={<AmbienceRightSidebar />}
      rightPanelWidth={260}
      forceSidebarSmall={true}
      leftPanelContent={
        <SpiralPathLeftSidebar
          isDark={true}
          currentLevel={1}
          totalLevels={5}
          completedStrands={completedStrands}
          totalStrands={totalStrandsCount}
          isLearning={pathMode !== 'skills'}
          onToggleLearning={() => setPathMode(pathMode === 'skills' ? 'path' : 'skills')}
        />
      }
    >
      <div className="min-h-screen bg-gradient-to-b from-zinc-50 to-white dark:from-zinc-950 dark:to-zinc-900">
        {/* Header - Mobile Responsive */}
        <header className="border-b border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 sticky top-11 z-30">
          <div className="container mx-auto px-3 md:px-4 py-3 md:py-4">
            <div className="flex items-center justify-between gap-2">
              {/* Left: Back + Title */}
              <div className="flex items-center gap-2 md:gap-4 min-w-0">
                {/* Mobile Menu Button */}
                <button
                  onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                  className="md:hidden p-2.5 hover:bg-zinc-100 dark:hover:bg-zinc-800 rounded-lg transition-colors touch-manipulation"
                  aria-label="Toggle filters menu"
                >
                  <Menu className="w-5 h-5" />
                </button>

                <Link
                  href="/quarry"
                  className="hidden md:flex p-2.5 hover:bg-zinc-100 dark:hover:bg-zinc-800 rounded-lg transition-colors touch-manipulation"
                >
                  <ArrowLeft className="w-5 h-5" />
                </Link>

                <div className="min-w-0">
                  <h1 className="text-lg md:text-2xl font-bold flex items-center gap-1.5 md:gap-2">
                    <Route className="w-5 h-5 md:w-6 md:h-6 text-emerald-500 flex-shrink-0" />
                    <span className="truncate">Spiral Path</span>
                  </h1>
                  <p className="text-xs md:text-sm text-zinc-500 hidden sm:block">
                    {filteredNodes.length} strands • {totalWeaves} weaves
                  </p>
                </div>
              </div>

              {/* Desktop View mode toggle */}
              <div className="hidden lg:flex items-center gap-2 bg-zinc-100 dark:bg-zinc-800 p-1 rounded-lg">
                <button
                  onClick={() => setViewMode('info')}
                  className={`
                    flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-all touch-manipulation
                    ${viewMode === 'info'
                      ? 'bg-white dark:bg-zinc-700 shadow text-cyan-600 dark:text-cyan-400'
                      : 'text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-100'
                    }
                  `}
                >
                  <Info className="w-4 h-4" />
                  About
                </button>
                <button
                  onClick={() => setViewMode('tree')}
                  className={`
                    flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-all touch-manipulation
                    ${viewMode === 'tree'
                      ? 'bg-white dark:bg-zinc-700 shadow text-emerald-600 dark:text-emerald-400'
                      : 'text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-100'
                    }
                  `}
                >
                  <TreePine className="w-4 h-4" />
                  Tree
                </button>
                <button
                  onClick={() => setViewMode('graph')}
                  className={`
                    flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-all touch-manipulation
                    ${viewMode === 'graph'
                      ? 'bg-white dark:bg-zinc-700 shadow text-emerald-600 dark:text-emerald-400'
                      : 'text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-100'
                    }
                  `}
                >
                  <Network className="w-4 h-4" />
                  Graph
                </button>
                <button
                  onClick={() => setViewMode('ascii')}
                  className={`
                    flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-all touch-manipulation
                    ${viewMode === 'ascii'
                      ? 'bg-white dark:bg-zinc-700 shadow text-violet-600 dark:text-violet-400'
                      : 'text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-100'
                    }
                  `}
                >
                  <Terminal className="w-4 h-4" />
                  ASCII
                </button>

                {/* Divider */}
                <div className="w-px h-6 bg-zinc-300 dark:bg-zinc-700" />

                {/* Link to Fabric Graph */}
                <Link
                  href="/quarry?graph=true"
                  className="flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium transition-all text-purple-600 dark:text-purple-400 hover:bg-purple-100 dark:hover:bg-purple-900/30 touch-manipulation"
                  title="Open the full Fabric Graph showing all weaves, looms, and strands with their relationships"
                >
                  <Layers className="w-4 h-4" />
                  Fabric
                </Link>
              </div>

              {/* Tablet: Compact view mode */}
              <div className="hidden md:flex lg:hidden items-center gap-1 bg-zinc-100 dark:bg-zinc-800 p-1 rounded-lg">
                {[
                  { mode: 'info' as ViewMode, icon: Info, color: 'cyan' },
                  { mode: 'tree' as ViewMode, icon: TreePine, color: 'emerald' },
                  { mode: 'graph' as ViewMode, icon: Network, color: 'emerald' },
                  { mode: 'ascii' as ViewMode, icon: Terminal, color: 'violet' },
                ].map(({ mode, icon: Icon, color }) => (
                  <button
                    key={mode}
                    onClick={() => setViewMode(mode)}
                    className={`
                      p-2.5 rounded-md transition-all touch-manipulation
                      ${viewMode === mode
                        ? `bg-white dark:bg-zinc-700 shadow text-${color}-600 dark:text-${color}-400`
                        : 'text-zinc-600 dark:text-zinc-400 hover:text-zinc-900 dark:hover:text-zinc-100'
                      }
                    `}
                    title={mode.charAt(0).toUpperCase() + mode.slice(1)}
                  >
                    <Icon className="w-5 h-5" />
                  </button>
                ))}
              </div>

              {/* Mobile: Filter + Detail toggles */}
              <div className="flex md:hidden items-center gap-1">
                {selectedNode && (
                  <button
                    onClick={() => setMobileDetailOpen(!mobileDetailOpen)}
                    className="p-2.5 hover:bg-zinc-100 dark:hover:bg-zinc-800 rounded-lg transition-colors touch-manipulation"
                    aria-label="View details"
                  >
                    <Info className="w-5 h-5 text-emerald-500" />
                  </button>
                )}
                <Link
                  href="/quarry"
                  className="p-2.5 hover:bg-zinc-100 dark:hover:bg-zinc-800 rounded-lg transition-colors touch-manipulation"
                >
                  <ArrowLeft className="w-5 h-5" />
                </Link>
              </div>
            </div>
          </div>
        </header>
        
        <div className="flex h-[calc(100vh-57px)] md:h-[calc(100vh-73px)] relative">
          {/* Mobile Drawer Overlay */}
          <AnimatePresence>
            {(mobileMenuOpen || mobileDetailOpen) && (isMobile || isTablet) && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="fixed inset-0 bg-black/50 z-40 md:hidden"
                onClick={() => {
                  setMobileMenuOpen(false)
                  setMobileDetailOpen(false)
                }}
              />
            )}
          </AnimatePresence>

          {/* Left Sidebar - Filters & Skills (Desktop: sidebar, Mobile: drawer) */}
          <AnimatePresence>
            {(showFilters || mobileMenuOpen) && (
              <motion.aside
                initial={{ x: isMobile ? -320 : 0, width: isMobile ? 320 : 0, opacity: 0 }}
                animate={{ x: 0, width: isMobile ? 'min(320px, 85vw)' : 320, opacity: 1 }}
                exit={{ x: isMobile ? -320 : 0, width: isMobile ? 320 : 0, opacity: 0 }}
                transition={{ type: 'spring', damping: 25, stiffness: 300 }}
                className={`
                  border-r border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 overflow-hidden flex-shrink-0
                  ${isMobile ? 'fixed left-0 top-[57px] bottom-0 z-50 shadow-2xl' : ''}
                `}
              >
                <div className="h-full overflow-y-auto p-4 space-y-6">
                  {/* Path Planner */}
                  <div className="space-y-3">
                    <h3 className="font-semibold text-sm flex items-center gap-2">
                      <Target className="w-4 h-4 text-emerald-500" />
                      Path Planner
                    </h3>
                    
                    <div className="space-y-2">
                      <div>
                        <label className="text-xs text-zinc-500">Start Point</label>
                        <div className="mt-1 p-2 bg-zinc-50 dark:bg-zinc-800 rounded-lg text-sm">
                          {pathStart ? (
                            <div className="flex items-center justify-between">
                              <span className="truncate">{pathNodes.find(n => n.id === pathStart)?.title || pathStart}</span>
                              <button onClick={() => setPathStart(null)} className="p-1 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded">
                                <X className="w-3 h-3" />
                              </button>
                            </div>
                          ) : (
                            <span className="text-zinc-400">Select a strand to start</span>
                          )}
                        </div>
                      </div>
                      
                      <div>
                        <label className="text-xs text-zinc-500">Goal</label>
                        <div className="mt-1 p-2 bg-zinc-50 dark:bg-zinc-800 rounded-lg text-sm">
                          {pathEnd ? (
                            <div className="flex items-center justify-between">
                              <span className="truncate">{pathNodes.find(n => n.id === pathEnd)?.title || pathEnd}</span>
                              <button onClick={() => setPathEnd(null)} className="p-1 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded">
                                <X className="w-3 h-3" />
                              </button>
                            </div>
                          ) : (
                            <span className="text-zinc-400">Select a goal strand</span>
                          )}
                        </div>
                      </div>
                      
                      {calculatedPath.length > 0 && (
                        <div className="p-3 bg-gradient-to-br from-amber-50 to-orange-50 dark:from-amber-900/20 dark:to-orange-900/20 rounded-lg border border-amber-200 dark:border-amber-800/50">
                          {/* Header with stats */}
                          <div className="flex items-center justify-between mb-3">
                            <div className="flex items-center gap-2">
                              <Route className="w-4 h-4 text-amber-600" />
                              <span className="font-semibold text-amber-800 dark:text-amber-200">
                                Learning Path
                              </span>
                            </div>
                            <span className="text-xs px-2 py-0.5 bg-amber-200 dark:bg-amber-800 text-amber-800 dark:text-amber-200 rounded-full">
                              {calculatedPath.length} steps
                            </span>
                          </div>

                          {/* Total time estimate */}
                          <div className="flex items-center gap-4 mb-3 text-xs text-amber-700 dark:text-amber-300">
                            <span>
                              ⏱ ~{calculatedPath.reduce((sum, id) => {
                                const node = pathNodes.find(n => n.id === id)
                                return sum + (node?.estimatedTime || 5)
                              }, 0)} min total
                            </span>
                          </div>

                          {/* Path steps */}
                          <div className="space-y-1.5 max-h-48 overflow-y-auto">
                            {calculatedPath.map((id, i) => {
                              const node = pathNodes.find(n => n.id === id)
                              const isFirst = i === 0
                              const isLast = i === calculatedPath.length - 1
                              return (
                                <button
                                  key={id}
                                  onClick={() => node && setSelectedNode(node)}
                                  className="w-full flex items-center gap-2 p-2 rounded-lg bg-white/60 dark:bg-zinc-800/60 hover:bg-white dark:hover:bg-zinc-800 transition-colors text-left group"
                                >
                                  <span className={`
                                    w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold
                                    ${isFirst ? 'bg-emerald-500 text-white' : isLast ? 'bg-amber-500 text-white' : 'bg-zinc-300 dark:bg-zinc-600 text-zinc-700 dark:text-zinc-200'}
                                  `}>
                                    {i + 1}
                                  </span>
                                  <div className="flex-1 min-w-0">
                                    <span className="text-sm truncate block text-zinc-800 dark:text-zinc-200">
                                      {node?.title || id}
                                    </span>
                                    <span className="text-[10px] text-zinc-500">
                                      {node?.difficulty} • ~{node?.estimatedTime || 5}min
                                    </span>
                                  </div>
                                  {isFirst && <span className="text-[10px] text-emerald-600 dark:text-emerald-400">START</span>}
                                  {isLast && <span className="text-[10px] text-amber-600 dark:text-amber-400">GOAL</span>}
                                </button>
                              )
                            })}
                          </div>

                          {/* Actions */}
                          <div className="flex items-center gap-2 mt-3 pt-3 border-t border-amber-200 dark:border-amber-800/50">
                            <button
                              onClick={handleClearPath}
                              className="flex-1 px-3 py-1.5 text-xs text-amber-700 dark:text-amber-300 hover:bg-amber-100 dark:hover:bg-amber-900/40 rounded transition-colors"
                            >
                              Clear
                            </button>
                            <button
                              onClick={handleExportPath}
                              className="flex-1 px-3 py-1.5 text-xs bg-amber-500 text-white hover:bg-amber-600 rounded transition-colors font-medium"
                            >
                              Export ↓
                            </button>
                          </div>

                          {/* Algorithm Explanation - Collapsible */}
                          <details className="mt-3 pt-3 border-t border-amber-200 dark:border-amber-800/50">
                            <summary className="flex items-center gap-1.5 text-xs text-amber-600 dark:text-amber-400 cursor-pointer hover:text-amber-700 dark:hover:text-amber-300">
                              <HelpCircle className="w-3 h-3" />
                              How was this path calculated?
                            </summary>
                            <div className="mt-2 p-2 bg-white/50 dark:bg-zinc-900/50 rounded text-[10px] text-zinc-600 dark:text-zinc-400 space-y-1.5">
                              <p className="font-medium text-zinc-700 dark:text-zinc-300">
                                Dijkstra&apos;s Algorithm
                              </p>
                              <p>
                                Finds the shortest path using weighted edges:
                              </p>
                              <ul className="list-disc ml-3 space-y-0.5">
                                <li><span className="text-emerald-600 dark:text-emerald-400">Prerequisites</span>: 1.0 (explicit)</li>
                                <li><span className="text-cyan-600 dark:text-cyan-400">Tag similarity</span>: 0.2-0.8</li>
                                <li><span className="text-violet-600 dark:text-violet-400">Folder proximity</span>: 0.5</li>
                                <li><span className="text-amber-600 dark:text-amber-400">Difficulty flow</span>: 0.3</li>
                              </ul>
                              <a
                                href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
                                target="_blank"
                                rel="noopener noreferrer"
                                className="block mt-1 text-cyan-600 dark:text-cyan-400 hover:underline"
                              >
                                Learn more →
                              </a>
                            </div>
                          </details>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {/* Smart Quick Filters */}
                  <div className="space-y-3">
                    <h3 className="font-semibold text-sm flex items-center gap-2">
                      <Zap className="w-4 h-4 text-amber-500" />
                      Quick Filters
                    </h3>
                    
                    <div className="grid grid-cols-2 gap-2">
                      <button
                        onClick={() => setFilters(f => ({ ...f, difficulty: 'beginner', showCompleted: false }))}
                        className={`
                          p-2 rounded-lg text-xs font-medium transition-all text-left
                          ${filters.difficulty === 'beginner' && !filters.showCompleted
                            ? 'bg-emerald-100 dark:bg-emerald-900/40 text-emerald-700 dark:text-emerald-300 ring-2 ring-emerald-500/30'
                            : 'bg-zinc-50 dark:bg-zinc-800/50 text-zinc-600 dark:text-zinc-400 hover:bg-zinc-100 dark:hover:bg-zinc-800'
                          }
                        `}
                      >
                        <span className="block text-emerald-500">🌱</span>
                        Getting Started
                      </button>
                      <button
                        onClick={() => {
                          // Find strands with most prerequisites met
                          const readyNodes = pathNodes.filter(n => n.prerequisites.length <= 1 && n.mastery < 50)
                          if (readyNodes.length > 0) {
                            setFilters(f => ({ ...f, searchQuery: '', difficulty: null, showCompleted: false }))
                          }
                        }}
                        className="p-2 rounded-lg text-xs font-medium bg-zinc-50 dark:bg-zinc-800/50 text-zinc-600 dark:text-zinc-400 hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-all text-left"
                      >
                        <span className="block text-cyan-500">🎯</span>
                        Ready to Learn
                      </button>
                      <button
                        onClick={() => setFilters(f => ({ ...f, showCompleted: true, difficulty: null }))}
                        className={`
                          p-2 rounded-lg text-xs font-medium transition-all text-left
                          ${filters.showCompleted && !filters.difficulty
                            ? 'bg-violet-100 dark:bg-violet-900/40 text-violet-700 dark:text-violet-300 ring-2 ring-violet-500/30'
                            : 'bg-zinc-50 dark:bg-zinc-800/50 text-zinc-600 dark:text-zinc-400 hover:bg-zinc-100 dark:hover:bg-zinc-800'
                          }
                        `}
                      >
                        <span className="block text-violet-500">📚</span>
                        Show All
                      </button>
                      <button
                        onClick={() => setFilters({
                          weave: null,
                          loom: null,
                          tags: [],
                          difficulty: null,
                          showCompleted: true,
                          searchQuery: '',
                        })}
                        className="p-2 rounded-lg text-xs font-medium bg-zinc-50 dark:bg-zinc-800/50 text-zinc-600 dark:text-zinc-400 hover:bg-rose-100 dark:hover:bg-rose-900/30 hover:text-rose-600 dark:hover:text-rose-400 transition-all text-left"
                      >
                        <span className="block text-rose-500">✕</span>
                        Clear Filters
                      </button>
                    </div>
                  </div>
                  
                  {/* Selected Strand Prerequisites */}
                  {selectedNode && selectedNode.prerequisites.length > 0 && (
                    <div className="space-y-3 p-3 bg-rose-50 dark:bg-rose-900/20 rounded-lg border border-rose-200 dark:border-rose-800/50">
                      <h3 className="font-semibold text-sm flex items-center gap-2 text-rose-700 dark:text-rose-300">
                        <ArrowLeft className="w-4 h-4" />
                        Prerequisites for &quot;{selectedNode.title}&quot;
                      </h3>
                      <div className="space-y-1.5">
                        {selectedNode.prerequisites.map(prereq => {
                          const prereqNode = pathNodes.find(n => n.path === prereq || n.id === prereq)
                          return (
                            <button
                              key={prereq}
                              onClick={() => {
                                if (prereqNode) {
                                  setSelectedNode(prereqNode)
                                }
                              }}
                              className="w-full flex items-center gap-2 p-2 rounded-lg bg-white dark:bg-zinc-800 border border-rose-200 dark:border-rose-800/50 text-sm text-left hover:bg-rose-100 dark:hover:bg-rose-900/40 transition-all group"
                            >
                              <BookOpen className="w-3.5 h-3.5 text-rose-500 flex-shrink-0" />
                              <span className="flex-1 truncate text-zinc-700 dark:text-zinc-300">
                                {prereqNode?.title || prereq.split('/').pop()?.replace('.md', '')}
                              </span>
                              {prereqNode && (
                                <span className={`text-[10px] px-1.5 py-0.5 rounded-full ${
                                  prereqNode.mastery >= 80 
                                    ? 'bg-emerald-100 dark:bg-emerald-900/50 text-emerald-600 dark:text-emerald-400' 
                                    : 'bg-amber-100 dark:bg-amber-900/50 text-amber-600 dark:text-amber-400'
                                }`}>
                                  {prereqNode.mastery >= 80 ? '✓' : `${prereqNode.mastery}%`}
                                </span>
                              )}
                              <ChevronRight className="w-3.5 h-3.5 text-zinc-400 opacity-0 group-hover:opacity-100 transition-opacity" />
                            </button>
                          )
                        })}
                      </div>
                    </div>
                  )}

                  {/* Filters */}
                  <div className="space-y-3">
                    <h3 className="font-semibold text-sm flex items-center gap-2">
                      <Filter className="w-4 h-4 text-cyan-500" />
                      Filters
                      {(filters.weave || filters.difficulty || filters.tags.length > 0 || filters.searchQuery) && (
                        <span className="ml-auto text-[10px] px-1.5 py-0.5 bg-cyan-100 dark:bg-cyan-900/50 text-cyan-600 dark:text-cyan-400 rounded-full">
                          Active
                        </span>
                      )}
                    </h3>
                    
                    <div className="relative">
                      <label className="text-xs text-zinc-500 dark:text-zinc-400">Search</label>
                      <div className="relative mt-1">
                        <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-zinc-400" />
                        <input
                          type="text"
                          value={filters.searchQuery}
                          onChange={(e) => setFilters(f => ({ ...f, searchQuery: e.target.value }))}
                          placeholder="Search strands, tags..."
                          className="w-full pl-9 pr-8 py-2.5 bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 rounded-lg text-sm focus:ring-2 focus:ring-cyan-500/30 focus:border-cyan-500 transition-all"
                        />
                        {filters.searchQuery && (
                          <button
                            onClick={() => setFilters(f => ({ ...f, searchQuery: '' }))}
                            className="absolute right-2 top-1/2 -translate-y-1/2 p-1 hover:bg-zinc-200 dark:hover:bg-zinc-700 rounded transition-colors"
                          >
                            <X className="w-3 h-3 text-zinc-400" />
                          </button>
                        )}
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-2 gap-2">
                      <div>
                        <label className="text-xs text-zinc-500 dark:text-zinc-400">Weave</label>
                        <select
                          value={filters.weave || ''}
                          onChange={(e) => setFilters(f => ({ ...f, weave: e.target.value || null }))}
                          className="mt-1 w-full px-3 py-2 bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 rounded-lg text-sm focus:ring-2 focus:ring-cyan-500/30 focus:border-cyan-500 transition-all"
                        >
                          <option value="">All weaves</option>
                          {weavesIndex.map(w => (
                            <option key={w} value={w}>{w}</option>
                          ))}
                        </select>
                      </div>
                      
                      <div>
                        <label className="text-xs text-zinc-500 dark:text-zinc-400">Difficulty</label>
                        <select
                          value={filters.difficulty || ''}
                          onChange={(e) => setFilters(f => ({ ...f, difficulty: e.target.value || null }))}
                          className="mt-1 w-full px-3 py-2 bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 rounded-lg text-sm focus:ring-2 focus:ring-cyan-500/30 focus:border-cyan-500 transition-all"
                        >
                          <option value="">All levels</option>
                          <option value="beginner">🌱 Beginner</option>
                          <option value="intermediate">🌿 Intermediate</option>
                          <option value="advanced">🌳 Advanced</option>
                          <option value="expert">🏔️ Expert</option>
                        </select>
                      </div>
                    </div>
                    
                    <div>
                      <div className="flex items-center justify-between mb-1.5">
                        <label className="text-xs text-zinc-500 dark:text-zinc-400">Tags</label>
                        {filters.tags.length > 0 && (
                          <button
                            onClick={() => setFilters(f => ({ ...f, tags: [] }))}
                            className="text-[10px] text-cyan-600 dark:text-cyan-400 hover:underline"
                          >
                            Clear ({filters.tags.length})
                          </button>
                        )}
                      </div>
                      <div className="flex flex-wrap gap-1.5 max-h-40 overflow-y-auto p-2 bg-zinc-50 dark:bg-zinc-800/50 rounded-lg border border-zinc-200 dark:border-zinc-700">
                        {tagsIndex.slice(0, 30).map(tag => (
                          <button
                            key={tag.name}
                            onClick={() => {
                              setFilters(f => ({
                                ...f,
                                tags: f.tags.includes(tag.name)
                                  ? f.tags.filter(t => t !== tag.name)
                                  : [...f.tags, tag.name]
                              }))
                            }}
                            className={`
                              px-2.5 py-1 text-xs rounded-full transition-all font-medium
                              ${filters.tags.includes(tag.name)
                                ? 'bg-emerald-500 text-white shadow-sm shadow-emerald-500/30'
                                : 'bg-white dark:bg-zinc-700 text-zinc-600 dark:text-zinc-300 hover:bg-emerald-100 dark:hover:bg-emerald-900/30 hover:text-emerald-700 dark:hover:text-emerald-300 border border-zinc-200 dark:border-zinc-600'
                              }
                            `}
                          >
                            {tag.name}
                            <span className={`ml-1 ${filters.tags.includes(tag.name) ? 'text-emerald-200' : 'text-zinc-400 dark:text-zinc-500'}`}>
                              {tag.count}
                            </span>
                          </button>
                        ))}
                        {tagsIndex.length > 30 && (
                          <span className="text-xs text-zinc-400 dark:text-zinc-500 px-2 py-1">
                            +{tagsIndex.length - 30} more
                          </span>
                        )}
                      </div>
                    </div>
                    
                    <label className="flex items-center gap-3 text-sm p-2 rounded-lg hover:bg-zinc-50 dark:hover:bg-zinc-800/50 transition-colors cursor-pointer">
                      <input
                        type="checkbox"
                        checked={filters.showCompleted}
                        onChange={(e) => setFilters(f => ({ ...f, showCompleted: e.target.checked }))}
                        className="rounded border-zinc-300 dark:border-zinc-600 text-emerald-500 focus:ring-emerald-500/30"
                      />
                      <span className="text-zinc-700 dark:text-zinc-300">Show completed strands</span>
                      <CheckCircle className={`w-4 h-4 ml-auto ${filters.showCompleted ? 'text-emerald-500' : 'text-zinc-300 dark:text-zinc-600'}`} />
                    </label>
                  </div>
                  
                  {/* Skills Panel */}
                  <div className="space-y-3">
                    <button
                      onClick={() => setShowSkillPanel(!showSkillPanel)}
                      className="w-full flex items-center justify-between font-semibold text-sm"
                    >
                      <span className="flex items-center gap-2">
                        <GraduationCap className="w-4 h-4 text-violet-500" />
                        Your Skills
                      </span>
                      {showSkillPanel ? <ChevronDown className="w-4 h-4" /> : <ChevronRight className="w-4 h-4" />}
                    </button>
                    
                    <AnimatePresence>
                      {showSkillPanel && (
                        <motion.div
                          initial={{ height: 0, opacity: 0 }}
                          animate={{ height: 'auto', opacity: 1 }}
                          exit={{ height: 0, opacity: 0 }}
                          className="space-y-2 overflow-hidden"
                        >
                          <p className="text-xs text-zinc-500">
                            Add your skill levels to personalize the learning path.
                          </p>
                          
                          <div className="flex gap-2">
                            <input
                              type="text"
                              value={newSkillName}
                              onChange={(e) => setNewSkillName(e.target.value)}
                              placeholder="e.g., TypeScript, React..."
                              className="flex-1 px-3 py-2 bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 rounded-lg text-sm"
                              onKeyDown={(e) => e.key === 'Enter' && handleAddSkill()}
                            />
                            <button
                              onClick={handleAddSkill}
                              className="px-3 py-2 bg-emerald-500 text-white rounded-lg text-sm hover:bg-emerald-600"
                            >
                              Add
                            </button>
                          </div>
                          
                          <div className="space-y-2 max-h-48 overflow-y-auto">
                            {skills.map((skill, i) => (
                              <SkillInput
                                key={i}
                                skill={skill}
                                onChange={(updated) => {
                                  setSkills(prev => prev.map((s, j) => j === i ? updated : s))
                                }}
                                onRemove={() => {
                                  setSkills(prev => prev.filter((_, j) => j !== i))
                                }}
                              />
                            ))}
                          </div>
                        </motion.div>
                      )}
                    </AnimatePresence>
                  </div>
                </div>
              </motion.aside>
            )}
          </AnimatePresence>
          
          {/* Main Content */}
          <main className="flex-1 overflow-hidden relative">
            {/* Toggle filters button */}
            <button
              onClick={() => setShowFilters(!showFilters)}
              className="absolute top-4 left-4 z-10 p-2 bg-white dark:bg-zinc-900 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700"
            >
              {showFilters ? <ChevronLeft className="w-5 h-5" /> : <Sliders className="w-5 h-5" />}
            </button>
            
            {treeLoading ? (
              <div className="flex items-center justify-center h-full">
                <div className="text-center space-y-4">
                  <motion.div
                    animate={{ rotate: 360 }}
                    transition={{ duration: 2, repeat: Infinity, ease: 'linear' }}
                  >
                    <Sparkles className="w-12 h-12 text-emerald-500" />
                  </motion.div>
                  <p className="text-zinc-500">Loading knowledge tree...</p>
                </div>
              </div>
            ) : treeError ? (
              <div className="flex items-center justify-center h-full">
                <div className="text-center space-y-4 max-w-md">
                  <AlertCircle className="w-12 h-12 text-red-500 mx-auto" />
                  <p className="text-red-600">{treeError}</p>
                  <Link
                    href="/quarry"
                    className="inline-flex items-center gap-2 px-4 py-2 bg-zinc-100 dark:bg-zinc-800 rounded-lg"
                  >
                    <ArrowLeft className="w-4 h-4" />
                    Back to Codex
                  </Link>
                </div>
              </div>
            ) : viewMode === 'info' ? (
              /* About / Info Landing Page */
              <div className="h-full overflow-y-auto">
                <div className="max-w-4xl mx-auto py-12 px-6 space-y-12">
                  {/* Hero Section */}
                  <div className="text-center space-y-4">
                    <div className="inline-flex items-center justify-center w-20 h-20 rounded-2xl bg-gradient-to-br from-emerald-400 to-cyan-500 text-white shadow-lg shadow-emerald-500/25">
                      <Route className="w-10 h-10" />
                    </div>
                    <h1 className="text-4xl font-bold bg-gradient-to-r from-emerald-600 to-cyan-600 bg-clip-text text-transparent">
                      Spiral Path
                    </h1>
                    <p className="text-xl text-zinc-600 dark:text-zinc-400 max-w-2xl mx-auto">
                      Navigate your learning journey through the Quarry Codex knowledge graph. 
                      Discover optimal paths, track progress, and master concepts systematically.
                    </p>
                  </div>

                  {/* Features Grid */}
                  <div className="grid md:grid-cols-2 gap-6">
                    <div className="p-6 rounded-2xl bg-gradient-to-br from-emerald-50 to-emerald-100 dark:from-emerald-950/40 dark:to-emerald-900/40 border border-emerald-200 dark:border-emerald-800">
                      <div className="flex items-center gap-3 mb-3">
                        <div className="p-2 rounded-lg bg-emerald-500 text-white">
                          <TreePine className="w-5 h-5" />
                        </div>
                        <h3 className="font-semibold text-lg">Tree View</h3>
                      </div>
                      <p className="text-sm text-zinc-600 dark:text-zinc-400">
                        Explore knowledge hierarchically. Navigate through weaves, looms, and strands 
                        with an expandable outline view perfect for structured browsing.
                      </p>
                    </div>
                    
                    <div className="p-6 rounded-2xl bg-gradient-to-br from-cyan-50 to-cyan-100 dark:from-cyan-950/40 dark:to-cyan-900/40 border border-cyan-200 dark:border-cyan-800">
                      <div className="flex items-center gap-3 mb-3">
                        <div className="p-2 rounded-lg bg-cyan-500 text-white">
                          <Network className="w-5 h-5" />
                        </div>
                        <h3 className="font-semibold text-lg">Graph View</h3>
                      </div>
                      <p className="text-sm text-zinc-600 dark:text-zinc-400">
                        Visualize relationships in a force-directed graph. See how strands connect 
                        through prerequisites and references. Drag, zoom, and explore connections.
                      </p>
                    </div>
                    
                    <div className="p-6 rounded-2xl bg-gradient-to-br from-amber-50 to-amber-100 dark:from-amber-950/40 dark:to-amber-900/40 border border-amber-200 dark:border-amber-800">
                      <div className="flex items-center gap-3 mb-3">
                        <div className="p-2 rounded-lg bg-amber-500 text-white">
                          <Target className="w-5 h-5" />
                        </div>
                        <h3 className="font-semibold text-lg">Path Planner</h3>
                      </div>
                      <p className="text-sm text-zinc-600 dark:text-zinc-400">
                        Set a start point and goal, then let the algorithm find the optimal learning path.
                        Based on prerequisite chains and difficulty progression.
                      </p>
                    </div>
                    
                    <div className="p-6 rounded-2xl bg-gradient-to-br from-rose-50 to-rose-100 dark:from-rose-950/40 dark:to-rose-900/40 border border-rose-200 dark:border-rose-800">
                      <div className="flex items-center gap-3 mb-3">
                        <div className="p-2 rounded-lg bg-rose-500 text-white">
                          <GraduationCap className="w-5 h-5" />
                        </div>
                        <h3 className="font-semibold text-lg">Skill Tracking</h3>
                      </div>
                      <p className="text-sm text-zinc-600 dark:text-zinc-400">
                        Add your current skills and track mastery levels. Get personalized path 
                        recommendations based on what you already know.
                      </p>
                    </div>
                  </div>

                  {/* Spiral Curriculum Theory */}
                  <div className="p-6 rounded-2xl bg-zinc-50 dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800">
                    <div className="flex items-center gap-3 mb-4">
                      <Sparkles className="w-6 h-6 text-amber-500" />
                      <h3 className="font-semibold text-lg">The Spiral Curriculum</h3>
                    </div>
                    <blockquote className="italic text-zinc-600 dark:text-zinc-400 border-l-4 border-amber-400 pl-4 mb-4">
                      &ldquo;Any subject can be taught effectively in some intellectually honest form 
                      to any child at any stage of development.&rdquo;
                    </blockquote>
                    <p className="text-sm text-zinc-500">
                      — Jerome Bruner, cognitive psychologist. The spiral approach revisits topics 
                      at increasing complexity, building on prior knowledge with each pass.
                    </p>
                  </div>

                  {/* How to Use */}
                  <div className="space-y-4">
                    <h3 className="font-semibold text-lg flex items-center gap-2">
                      <BookOpen className="w-5 h-5 text-cyan-500" />
                      How to Use
                    </h3>
                    <div className="grid gap-3">
                      <div className="flex gap-4 items-start p-4 rounded-xl bg-white dark:bg-zinc-800/50 border border-zinc-200 dark:border-zinc-700">
                        <span className="w-8 h-8 rounded-full bg-emerald-100 dark:bg-emerald-900/40 text-emerald-600 flex items-center justify-center font-bold">1</span>
                        <div>
                          <p className="font-medium">Filter & Browse</p>
                          <p className="text-sm text-zinc-500">Use the left sidebar to filter by weave, difficulty, or tags. Search for specific topics.</p>
                        </div>
                      </div>
                      <div className="flex gap-4 items-start p-4 rounded-xl bg-white dark:bg-zinc-800/50 border border-zinc-200 dark:border-zinc-700">
                        <span className="w-8 h-8 rounded-full bg-emerald-100 dark:bg-emerald-900/40 text-emerald-600 flex items-center justify-center font-bold">2</span>
                        <div>
                          <p className="font-medium">Plan Your Path</p>
                          <p className="text-sm text-zinc-500">Click strands to select start/goal points. The path planner calculates the optimal route.</p>
                        </div>
                      </div>
                      <div className="flex gap-4 items-start p-4 rounded-xl bg-white dark:bg-zinc-800/50 border border-zinc-200 dark:border-zinc-700">
                        <span className="w-8 h-8 rounded-full bg-emerald-100 dark:bg-emerald-900/40 text-emerald-600 flex items-center justify-center font-bold">3</span>
                        <div>
                          <p className="font-medium">Track Progress</p>
                          <p className="text-sm text-zinc-500">Add your existing skills in the Skills panel. Mastery rings show your progress on each strand.</p>
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* CTA */}
                  <div className="text-center space-y-4">
                    <button
                      onClick={() => setViewMode('tree')}
                      className="inline-flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-emerald-500 to-cyan-500 text-white font-semibold rounded-xl shadow-lg shadow-emerald-500/25 hover:shadow-emerald-500/40 transition-all"
                    >
                      <Play className="w-5 h-5" />
                      Start Exploring
                    </button>
                    <p className="text-sm text-zinc-500">
                      {totalStrands} strands • {totalWeaves} weaves available
                    </p>
                  </div>
                </div>
              </div>
            ) : viewMode === 'tree' ? (
              <div className="h-full overflow-y-auto p-4">
                <div className="max-w-4xl mx-auto space-y-2">
                  {filteredNodes.length === 0 ? (
                    <div className="text-center py-12 text-zinc-500">
                      <BookOpen className="w-12 h-12 mx-auto mb-4 opacity-50" />
                      <p>No strands match your filters.</p>
                    </div>
                  ) : (
                    filteredNodes.map(node => (
                      <TreeNode
                        key={node.id}
                        node={node}
                        depth={0}
                        expanded={expandedNodes.has(node.id)}
                        onToggle={() => handleToggleExpand(node.id)}
                        onSelect={() => setSelectedNode(node)}
                        selectedId={selectedNode?.id ?? null}
                        pathHighlight={pathHighlightSet}
                      />
                    ))
                  )}
                </div>
              </div>
            ) : viewMode === 'ascii' ? (
              // ASCII Visualization View
              <div className="h-full overflow-y-auto p-6 bg-zinc-900 dark:bg-black">
                <div className="max-w-3xl mx-auto">
                  {/* ASCII Header */}
                  <div className="mb-6">
                    <h2 className="text-xl font-bold text-emerald-400 font-mono mb-2">
                      ASCII Learning Path Visualization
                    </h2>
                    <p className="text-sm text-zinc-400 font-mono">
                      Terminal-friendly view • {calculatedPath.length > 0 ? `${calculatedPath.length} steps in path` : 'Set start and goal to see path'}
                    </p>
                  </div>

                  {calculatedPath.length > 0 ? (
                    <div className="space-y-4">
                      {/* ASCII Art Box */}
                      <div className="bg-black rounded-lg border border-zinc-700 p-4 font-mono text-sm overflow-x-auto">
                        <pre className="text-emerald-400 whitespace-pre">
{`
┌${'─'.repeat(52)}┐
│${'  LEARNING PATH'.padEnd(52)}│
│${'━'.repeat(52)}│
│${`  ${pathNodes.find(n => n.id === pathStart)?.title?.slice(0, 20) || 'Start'} → ${pathNodes.find(n => n.id === pathEnd)?.title?.slice(0, 20) || 'Goal'}`.padEnd(52).slice(0, 52)}│
│${`  ${calculatedPath.length} steps • ~${calculatedPath.reduce((sum, id) => sum + (pathNodes.find(n => n.id === id)?.estimatedTime || 5), 0)} minutes`.padEnd(52)}│
└${'─'.repeat(52)}┘
`}
                        </pre>

                        {/* Path Steps */}
                        {calculatedPath.map((id, i) => {
                          const node = pathNodes.find(n => n.id === id)
                          const isFirst = i === 0
                          const isLast = i === calculatedPath.length - 1
                          const label = isFirst ? '← START' : isLast ? '← GOAL' : ''
                          const color = isFirst ? 'text-emerald-400' : isLast ? 'text-amber-400' : 'text-violet-400'

                          return (
                            <div key={id} className="text-zinc-300">
                              <pre className={`whitespace-pre ${color}`}>
{`
    ┌${'─'.repeat(34)}┐
    │ ${String(i + 1).padStart(2)}. ${(node?.title || id).slice(0, 28).padEnd(28)} │ ${label}
    │    [${(node?.difficulty || 'unknown').padEnd(14)}]       │
    └${'─'.repeat(17)}┬${'─'.repeat(16)}┘`}
                              </pre>
                              {!isLast && (
                                <pre className="whitespace-pre text-zinc-500">
{`                  │
                  ▼`}
                                </pre>
                              )}
                            </div>
                          )
                        })}

                        <pre className="text-zinc-500 mt-6 whitespace-pre">
{`
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Generated by Quarry Codex Spiral Path
Algorithm: Dijkstra's Shortest Path with weighted edges
`}
                        </pre>
                      </div>

                      {/* Copy button */}
                      <button
                        onClick={exportAsASCII}
                        className="flex items-center gap-2 px-4 py-2 bg-violet-600 hover:bg-violet-500 text-white rounded-lg font-mono text-sm transition-colors"
                      >
                        <Copy className="w-4 h-4" />
                        Copy ASCII to Clipboard
                      </button>
                    </div>
                  ) : (
                    <div className="text-center py-12 font-mono">
                      <Terminal className="w-16 h-16 mx-auto mb-4 text-zinc-600" />
                      <p className="text-zinc-400 mb-2">No learning path calculated yet</p>
                      <p className="text-zinc-500 text-sm">
                        Select a start and goal strand in Tree or Graph view
                      </p>
                      <p className="text-zinc-600 text-xs mt-4">
                        Tip: Click a strand, then use &quot;Set as Start&quot; and &quot;Set as Goal&quot;
                      </p>
                    </div>
                  )}

                  {/* Algorithm Info Box */}
                  <div className="mt-8 p-4 bg-zinc-800/50 rounded-lg border border-zinc-700 font-mono text-xs">
                    <h3 className="text-cyan-400 font-bold mb-2 flex items-center gap-2">
                      <HelpCircle className="w-4 h-4" />
                      How Dijkstra&apos;s Algorithm Works
                    </h3>
                    <div className="text-zinc-400 space-y-2">
                      <p>
                        Dijkstra&apos;s algorithm finds the shortest path between nodes in a weighted graph.
                      </p>
                      <p className="text-zinc-500">
                        Edge weights are calculated using:
                      </p>
                      <ul className="list-disc list-inside text-zinc-500 ml-2 space-y-1">
                        <li>Explicit prerequisites (weight: 1.0)</li>
                        <li>Tag similarity - Jaccard index (weight: 0.2-0.8)</li>
                        <li>Folder proximity (weight: 0.5)</li>
                        <li>Difficulty progression (weight: 0.3)</li>
                      </ul>
                      <p className="text-zinc-600 mt-2">
                        <a
                          href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-cyan-500 hover:underline"
                        >
                          Learn more on Wikipedia →
                        </a>
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            ) : (
              <div className="h-full relative">
                <GraphLegend visible={showLegend} onToggle={() => setShowLegend(!showLegend)} />
                <svg ref={svgRef} className="w-full h-full" />

                {/* Mobile touch hint */}
                {isMobile && (
                  <div className="absolute top-4 left-1/2 -translate-x-1/2 px-3 py-1.5 bg-black/70 text-white text-xs rounded-full backdrop-blur-sm pointer-events-none animate-pulse">
                    Pinch to zoom • Double-tap to reset
                  </div>
                )}

                {/* Zoom controls */}
                <div className="absolute bottom-4 md:bottom-4 right-4 flex items-center gap-2 safe-area-inset-bottom">
                  <span className="text-xs text-zinc-500 bg-white dark:bg-zinc-900 px-2 py-1 rounded shadow">
                    {Math.round(zoom * 100)}%
                  </span>
                  <button
                    onClick={() => {
                      if (!svgRef.current) return
                      d3.select(svgRef.current)
                        .transition()
                        .call(d3.zoom<SVGSVGElement, unknown>().scaleBy as any, 1.5)
                    }}
                    className="p-2.5 md:p-2 bg-white dark:bg-zinc-900 rounded-lg shadow border border-zinc-200 dark:border-zinc-700 touch-manipulation min-w-[44px] min-h-[44px] md:min-w-0 md:min-h-0 flex items-center justify-center"
                  >
                    <ZoomIn className="w-5 h-5 md:w-4 md:h-4" />
                  </button>
                  <button
                    onClick={() => {
                      if (!svgRef.current) return
                      d3.select(svgRef.current)
                        .transition()
                        .call(d3.zoom<SVGSVGElement, unknown>().scaleBy as any, 0.67)
                    }}
                    className="p-2.5 md:p-2 bg-white dark:bg-zinc-900 rounded-lg shadow border border-zinc-200 dark:border-zinc-700 touch-manipulation min-w-[44px] min-h-[44px] md:min-w-0 md:min-h-0 flex items-center justify-center"
                  >
                    <ZoomOut className="w-5 h-5 md:w-4 md:h-4" />
                  </button>
                  <button
                    onClick={() => {
                      if (!svgRef.current) return
                      d3.select(svgRef.current)
                        .transition()
                        .call(d3.zoom<SVGSVGElement, unknown>().transform as any, d3.zoomIdentity)
                    }}
                    className="p-2.5 md:p-2 bg-white dark:bg-zinc-900 rounded-lg shadow border border-zinc-200 dark:border-zinc-700 touch-manipulation min-w-[44px] min-h-[44px] md:min-w-0 md:min-h-0 flex items-center justify-center"
                    title="Reset zoom"
                  >
                    <RotateCcw className="w-5 h-5 md:w-4 md:h-4" />
                  </button>
                </div>
              </div>
            )}
          </main>
          
          {/* Right Sidebar - Selected Node Details (Desktop: sidebar, Mobile: full-screen modal) */}
          <AnimatePresence>
            {selectedNode && (!isMobile || mobileDetailOpen) && (
              <motion.aside
                initial={{
                  width: isMobile ? '100%' : 0,
                  x: isMobile ? '100%' : 0,
                  opacity: 0
                }}
                animate={{
                  width: isMobile ? '100%' : isTablet ? 320 : 400,
                  x: 0,
                  opacity: 1
                }}
                exit={{
                  width: isMobile ? '100%' : 0,
                  x: isMobile ? '100%' : 0,
                  opacity: 0
                }}
                transition={{ type: 'spring', damping: 25, stiffness: 300 }}
                className={`
                  border-l border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 overflow-hidden flex-shrink-0
                  ${isMobile ? 'fixed inset-0 z-50' : ''}
                `}
              >
                <div className="h-full overflow-y-auto">
                  {/* Header */}
                  <div className="p-4 border-b border-zinc-200 dark:border-zinc-800 safe-area-inset-top">
                    <div className="flex items-start justify-between gap-3">
                      <div className="min-w-0 flex-1">
                        <h2 className="font-bold text-base md:text-lg truncate">{selectedNode.title}</h2>
                        <p className="text-xs text-zinc-500 mt-1 truncate">{selectedNode.path}</p>
                      </div>
                      <button
                        onClick={() => {
                          setSelectedNode(null)
                          setMobileDetailOpen(false)
                        }}
                        className="p-2.5 hover:bg-zinc-100 dark:hover:bg-zinc-800 rounded-lg touch-manipulation flex-shrink-0"
                      >
                        <X className="w-5 h-5" />
                      </button>
                    </div>
                    
                    {/* Badges */}
                    <div className="flex flex-wrap gap-2 mt-3">
                      <span
                        className="px-2 py-0.5 text-xs font-medium rounded"
                        style={{
                          backgroundColor: `${getDifficultyColor(selectedNode.difficulty)}20`,
                          color: getDifficultyColor(selectedNode.difficulty),
                        }}
                      >
                        {selectedNode.difficulty}
                      </span>
                      {selectedNode.estimatedTime && (
                        <span className="px-2 py-0.5 text-xs bg-zinc-100 dark:bg-zinc-800 rounded">
                          ~{selectedNode.estimatedTime} min
                        </span>
                      )}
                      <span className="px-2 py-0.5 text-xs bg-emerald-100 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-300 rounded">
                        {selectedNode.mastery}% mastery
                      </span>
                    </div>
                  </div>
                  
                  {/* Actions */}
                  <div className="p-4 border-b border-zinc-200 dark:border-zinc-800 space-y-2">
                    <button
                      onClick={() => handleNavigateToStrand(selectedNode.path)}
                      className="w-full flex items-center justify-center gap-2 px-4 py-2 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 transition-colors"
                    >
                      <BookOpen className="w-4 h-4" />
                      Open in Codex
                    </button>
                    <div className="flex gap-2">
                      <button
                        onClick={() => handleSetAsStart(selectedNode.id)}
                        disabled={pathStart === selectedNode.id}
                        className={`
                          flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors
                          ${pathStart === selectedNode.id
                            ? 'bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-300'
                            : 'bg-zinc-100 dark:bg-zinc-800 hover:bg-zinc-200 dark:hover:bg-zinc-700'
                          }
                        `}
                      >
                        <Play className="w-4 h-4" />
                        Set as Start
                      </button>
                      <button
                        onClick={() => handleSetAsEnd(selectedNode.id)}
                        disabled={pathEnd === selectedNode.id}
                        className={`
                          flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg text-sm transition-colors
                          ${pathEnd === selectedNode.id
                            ? 'bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-300'
                            : 'bg-zinc-100 dark:bg-zinc-800 hover:bg-zinc-200 dark:hover:bg-zinc-700'
                          }
                        `}
                      >
                        <Target className="w-4 h-4" />
                        Set as Goal
                      </button>
                    </div>
                  </div>
                  
                  {/* Summary */}
                  {selectedNode.summary && (
                    <div className="p-4 border-b border-zinc-200 dark:border-zinc-800">
                      <h3 className="text-sm font-semibold mb-2">Summary</h3>
                      <p className="text-sm text-zinc-600 dark:text-zinc-400">
                        {selectedNode.summary}
                      </p>
                    </div>
                  )}
                  
                  {/* Tags */}
                  {selectedNode.tags.length > 0 && (
                    <div className="p-4 border-b border-zinc-200 dark:border-zinc-800">
                      <h3 className="text-sm font-semibold mb-2">Tags</h3>
                      <div className="flex flex-wrap gap-1">
                        {selectedNode.tags.map(tag => (
                          <span
                            key={tag}
                            className="px-2 py-0.5 text-xs bg-zinc-100 dark:bg-zinc-800 rounded"
                          >
                            {tag}
                          </span>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Prerequisites */}
                  {selectedNode.prerequisites.length > 0 && (
                    <div className="p-4 border-b border-zinc-200 dark:border-zinc-800">
                      <h3 className="text-sm font-semibold mb-2 flex items-center gap-2">
                        <ArrowLeft className="w-4 h-4 text-rose-500" />
                        Prerequisites ({selectedNode.prerequisites.length})
                      </h3>
                      <div className="space-y-1">
                        {selectedNode.prerequisites.map(prereq => {
                          const prereqNode = pathNodes.find(n => n.id === prereq || n.path.endsWith(prereq))
                          return (
                            <button
                              key={prereq}
                              onClick={() => prereqNode && setSelectedNode(prereqNode)}
                              className="w-full text-left p-2 text-sm bg-zinc-50 dark:bg-zinc-800/50 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
                            >
                              {prereqNode?.title || prereq}
                            </button>
                          )
                        })}
                      </div>
                    </div>
                  )}
                  
                  {/* References */}
                  {selectedNode.references.length > 0 && (
                    <div className="p-4">
                      <h3 className="text-sm font-semibold mb-2 flex items-center gap-2">
                        <ArrowRight className="w-4 h-4 text-emerald-500" />
                        References ({selectedNode.references.length})
                      </h3>
                      <div className="space-y-1">
                        {selectedNode.references.map(ref => {
                          const refNode = pathNodes.find(n => n.id === ref || n.path.endsWith(ref))
                          return (
                            <button
                              key={ref}
                              onClick={() => refNode && setSelectedNode(refNode)}
                              className="w-full text-left p-2 text-sm bg-zinc-50 dark:bg-zinc-800/50 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
                            >
                              {refNode?.title || ref}
                            </button>
                          )
                        })}
                      </div>
                    </div>
                  )}
                </div>
              </motion.aside>
            )}
          </AnimatePresence>
        </div>
      </div>

      {/* Export Modal - Mobile Optimized */}
      <AnimatePresence>
        {exportModalOpen && calculatedPath.length > 0 && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-[100] flex items-end md:items-center justify-center bg-black/50 backdrop-blur-sm"
            onClick={() => setExportModalOpen(false)}
          >
            <motion.div
              initial={{ opacity: 0, y: isMobile ? 100 : 20, scale: isMobile ? 1 : 0.95 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: isMobile ? 100 : 20, scale: isMobile ? 1 : 0.95 }}
              className={`
                bg-white dark:bg-zinc-900 shadow-2xl border border-zinc-200 dark:border-zinc-700 w-full overflow-hidden
                ${isMobile
                  ? 'rounded-t-3xl max-h-[85vh]'
                  : 'rounded-2xl max-w-md mx-4'
                }
              `}
              onClick={(e) => e.stopPropagation()}
            >
              {/* Mobile drag handle */}
              {isMobile && (
                <div className="flex justify-center pt-3 pb-1">
                  <div className="w-10 h-1 bg-zinc-300 dark:bg-zinc-600 rounded-full" />
                </div>
              )}

              {/* Modal Header */}
              <div className="px-4 md:px-6 py-3 md:py-4 border-b border-zinc-200 dark:border-zinc-800 flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-amber-100 dark:bg-amber-900/30 rounded-lg">
                    <Download className="w-5 h-5 text-amber-600 dark:text-amber-400" />
                  </div>
                  <div>
                    <h3 className="font-bold text-lg text-zinc-900 dark:text-zinc-100">Export Learning Path</h3>
                    <p className="text-xs text-zinc-500">{calculatedPath.length} steps • ~{generateExportData().totalTime} minutes</p>
                  </div>
                </div>
                <button
                  onClick={() => setExportModalOpen(false)}
                  className="p-2 hover:bg-zinc-100 dark:hover:bg-zinc-800 rounded-lg transition-colors"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>

              {/* Export Options - Scrollable on mobile */}
              <div className="p-4 space-y-2 overflow-y-auto max-h-[60vh] md:max-h-none overscroll-contain">
                {/* JSON Export */}
                <button
                  onClick={exportAsJSON}
                  className="w-full flex items-center gap-3 p-3 md:p-3 rounded-xl bg-zinc-50 dark:bg-zinc-800/50 hover:bg-zinc-100 dark:hover:bg-zinc-800 active:bg-zinc-200 dark:active:bg-zinc-700 transition-colors text-left group touch-manipulation min-h-[56px]"
                >
                  <div className="p-2 bg-blue-100 dark:bg-blue-900/30 rounded-lg group-hover:scale-110 transition-transform">
                    <FileJson className="w-5 h-5 text-blue-600 dark:text-blue-400" />
                  </div>
                  <div className="flex-1">
                    <div className="font-medium text-zinc-900 dark:text-zinc-100">JSON Data</div>
                    <div className="text-xs text-zinc-500">Machine-readable format with full metadata</div>
                  </div>
                  <Download className="w-4 h-4 text-zinc-400 group-hover:text-zinc-600 dark:group-hover:text-zinc-300" />
                </button>

                {/* Text Export */}
                <button
                  onClick={exportAsText}
                  className="w-full flex items-center gap-3 p-3 rounded-xl bg-zinc-50 dark:bg-zinc-800/50 hover:bg-zinc-100 dark:hover:bg-zinc-800 active:bg-zinc-200 dark:active:bg-zinc-700 transition-colors text-left group touch-manipulation min-h-[56px]"
                >
                  <div className="p-2 bg-emerald-100 dark:bg-emerald-900/30 rounded-lg group-hover:scale-110 transition-transform">
                    <FileText className="w-5 h-5 text-emerald-600 dark:text-emerald-400" />
                  </div>
                  <div className="flex-1">
                    <div className="font-medium text-zinc-900 dark:text-zinc-100">Plain Text</div>
                    <div className="text-xs text-zinc-500">Human-readable formatted text</div>
                  </div>
                  <Download className="w-4 h-4 text-zinc-400 group-hover:text-zinc-600 dark:group-hover:text-zinc-300" />
                </button>

                {/* ASCII Export */}
                <button
                  onClick={exportAsASCII}
                  className="w-full flex items-center gap-3 p-3 rounded-xl bg-zinc-50 dark:bg-zinc-800/50 hover:bg-zinc-100 dark:hover:bg-zinc-800 active:bg-zinc-200 dark:active:bg-zinc-700 transition-colors text-left group touch-manipulation min-h-[56px]"
                >
                  <div className="p-2 bg-violet-100 dark:bg-violet-900/30 rounded-lg group-hover:scale-110 transition-transform">
                    <Terminal className="w-5 h-5 text-violet-600 dark:text-violet-400" />
                  </div>
                  <div className="flex-1">
                    <div className="font-medium text-zinc-900 dark:text-zinc-100">ASCII Art</div>
                    <div className="text-xs text-zinc-500">Terminal-friendly visualization + copied to clipboard</div>
                  </div>
                  <Download className="w-4 h-4 text-zinc-400 group-hover:text-zinc-600 dark:group-hover:text-zinc-300" />
                </button>

                {/* PNG Export */}
                <button
                  onClick={exportAsPNG}
                  className="w-full flex items-center gap-3 p-3 rounded-xl bg-zinc-50 dark:bg-zinc-800/50 hover:bg-zinc-100 dark:hover:bg-zinc-800 active:bg-zinc-200 dark:active:bg-zinc-700 transition-colors text-left group touch-manipulation min-h-[56px]"
                >
                  <div className="p-2 bg-pink-100 dark:bg-pink-900/30 rounded-lg group-hover:scale-110 transition-transform">
                    <Image className="w-5 h-5 text-pink-600 dark:text-pink-400" />
                  </div>
                  <div className="flex-1">
                    <div className="font-medium text-zinc-900 dark:text-zinc-100">PNG Image</div>
                    <div className="text-xs text-zinc-500">Screenshot of the knowledge graph</div>
                  </div>
                  <Download className="w-4 h-4 text-zinc-400 group-hover:text-zinc-600 dark:group-hover:text-zinc-300" />
                </button>

                {/* PDF Export */}
                <button
                  onClick={exportAsPDF}
                  className="w-full flex items-center gap-3 p-3 rounded-xl bg-zinc-50 dark:bg-zinc-800/50 hover:bg-zinc-100 dark:hover:bg-zinc-800 active:bg-zinc-200 dark:active:bg-zinc-700 transition-colors text-left group touch-manipulation min-h-[56px]"
                >
                  <div className="p-2 bg-red-100 dark:bg-red-900/30 rounded-lg group-hover:scale-110 transition-transform">
                    <FileDown className="w-5 h-5 text-red-600 dark:text-red-400" />
                  </div>
                  <div className="flex-1">
                    <div className="font-medium text-zinc-900 dark:text-zinc-100">PDF Guide</div>
                    <div className="text-xs text-zinc-500">Full guide with rendered markdown content</div>
                  </div>
                  <Download className="w-4 h-4 text-zinc-400 group-hover:text-zinc-600 dark:group-hover:text-zinc-300" />
                </button>

                {/* Copy to Clipboard */}
                <button
                  onClick={copyToClipboard}
                  className="w-full flex items-center gap-3 p-3 rounded-xl border-2 border-dashed border-zinc-200 dark:border-zinc-700 hover:border-zinc-300 dark:hover:border-zinc-600 hover:bg-zinc-50 dark:hover:bg-zinc-800/30 active:bg-zinc-100 dark:active:bg-zinc-800 transition-colors text-left group touch-manipulation min-h-[56px]"
                >
                  <div className="p-2 bg-zinc-100 dark:bg-zinc-800 rounded-lg group-hover:scale-110 transition-transform">
                    <Copy className="w-5 h-5 text-zinc-600 dark:text-zinc-400" />
                  </div>
                  <div className="flex-1">
                    <div className="font-medium text-zinc-900 dark:text-zinc-100">Copy to Clipboard</div>
                    <div className="text-xs text-zinc-500">Copy JSON data to clipboard</div>
                  </div>
                </button>
              </div>

              {/* Modal Footer */}
              <div className="px-6 py-3 border-t border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-800/50 safe-area-inset-bottom">
                <p className="text-xs text-zinc-500 text-center">
                  Path from <span className="font-medium">{generateExportData().start.title}</span> to <span className="font-medium">{generateExportData().goal.title}</span>
                </p>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Mobile Bottom Navigation */}
      <nav className="md:hidden fixed bottom-0 left-0 right-0 z-40 bg-white dark:bg-zinc-900 border-t border-zinc-200 dark:border-zinc-800 safe-area-inset-bottom">
        <div className="flex items-stretch justify-around">
          {[
            { mode: 'info' as ViewMode, icon: Info, label: 'About', color: 'cyan' },
            { mode: 'tree' as ViewMode, icon: TreePine, label: 'Tree', color: 'emerald' },
            { mode: 'graph' as ViewMode, icon: Network, label: 'Graph', color: 'emerald' },
            { mode: 'ascii' as ViewMode, icon: Terminal, label: 'ASCII', color: 'violet' },
          ].map(({ mode, icon: Icon, label, color }) => (
            <button
              key={mode}
              onClick={() => {
                setViewMode(mode)
                setMobileMenuOpen(false)
              }}
              className={`
                flex-1 flex flex-col items-center justify-center gap-0.5 py-2 px-1 touch-manipulation
                transition-colors min-h-[56px]
                ${viewMode === mode
                  ? `text-${color}-600 dark:text-${color}-400 bg-${color}-50 dark:bg-${color}-900/20`
                  : 'text-zinc-500 dark:text-zinc-400 active:bg-zinc-100 dark:active:bg-zinc-800'
                }
              `}
            >
              <Icon className={`w-5 h-5 ${viewMode === mode ? 'scale-110' : ''} transition-transform`} />
              <span className="text-[10px] font-medium">{label}</span>
            </button>
          ))}
          {/* Path indicator if path is calculated */}
          {calculatedPath.length > 0 && (
            <button
              onClick={() => handleExportPath()}
              className="flex-1 flex flex-col items-center justify-center gap-0.5 py-2 px-1 touch-manipulation
                text-amber-600 dark:text-amber-400 bg-amber-50 dark:bg-amber-900/20 min-h-[56px]"
            >
              <Route className="w-5 h-5" />
              <span className="text-[10px] font-medium">{calculatedPath.length} steps</span>
            </button>
          )}
        </div>
      </nav>

      {/* Spacer for mobile bottom nav */}
      <div className="md:hidden h-14" />
    </QuarryPageLayout>
  )
}

