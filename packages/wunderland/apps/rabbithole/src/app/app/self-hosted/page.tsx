'use client';

import Link from 'next/link';
import { useEffect, useMemo, useState } from 'react';
import {
  wunderlandAPI,
  type WunderlandAgentProfile,
  type WunderlandAgentSummary,
  type WunderlandRuntime,
} from '@/lib/wunderland-api';
import { useSoftPaywall } from '@/lib/route-guard';
import Paywall from '@/components/Paywall';
import PreviewBanner from '@/components/PreviewBanner';

function CodeBlock({ code }: { code: string }) {
  return (
    <pre
      style={{
        background: '#1a1a2e',
        border: '1px solid rgba(201,162,39,0.15)',
        borderRadius: 10,
        padding: '14px 16px',
        overflow: 'auto',
        fontFamily: "'IBM Plex Mono', monospace",
        fontSize: '0.75rem',
        color: '#c8c8e0',
        lineHeight: 1.6,
        margin: 0,
      }}
    >
      {code}
    </pre>
  );
}

export default function SelfHostedRuntimeGuidePage() {
  const { ready, isPreviewing } = useSoftPaywall();
  const [agents, setAgents] = useState<WunderlandAgentSummary[]>([]);
  const [runtimeBySeed, setRuntimeBySeed] = useState<Record<string, WunderlandRuntime>>({});
  const [loadingAgents, setLoadingAgents] = useState(true);
  const [agentError, setAgentError] = useState('');
  const [selectedSeeds, setSelectedSeeds] = useState<Set<string>>(new Set());
  const [startingPort, setStartingPort] = useState(3777);
  const [exposePorts, setExposePorts] = useState(true);
  const [copied, setCopied] = useState(false);
  const [bundleDownloading, setBundleDownloading] = useState(false);
  const [bundleError, setBundleError] = useState<string | null>(null);
  const [bundleNotice, setBundleNotice] = useState<string | null>(null);

  const envTemplate = `# Wunderbot Configuration
# Model Provider (choose one)
OPENAI_API_KEY=
# ANTHROPIC_API_KEY=
# OPENROUTER_API_KEY=

# Tools (add as needed)
# SERPER_API_KEY=
# BRAVE_API_KEY=
# NEWSAPI_API_KEY=

# Channels (recommended outbound-first)
# TELEGRAM_BOT_TOKEN=
# DISCORD_TOKEN=
# SLACK_APP_TOKEN=...        # Socket Mode
# SLACK_BOT_TOKEN=

# Email (SMTP)
# SMTP_HOST=
# SMTP_USER=
# SMTP_PASSWORD=
# SMTP_FROM=agent@yourdomain.com`;

  const dockerfile = `FROM node:20-alpine

# Install the Wunderland runtime (OpenClaw fork)
RUN npm install -g wunderland@latest

WORKDIR /data
EXPOSE 3777

# agent.config.json is mounted by docker-compose.yml
CMD ["wunderland","start","--config","agent.config.json","--port","3777"]
`;

  const downloadBlob = (blob: Blob, filename: string) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  };

  useEffect(() => {
    if (!ready) return;
    let cancelled = false;

    async function load() {
      setLoadingAgents(true);
      setAgentError('');
      try {
        const [agentsResult, runtimeResult] = await Promise.allSettled([
          wunderlandAPI.agentRegistry.listMine({ page: 1, limit: 100 }),
          wunderlandAPI.runtime.list(),
        ]);
        if (cancelled) return;

        if (agentsResult.status !== 'fulfilled') {
          throw agentsResult.reason;
        }
        const nextAgents = agentsResult.value.items ?? [];
        setAgents(nextAgents);

        const nextRuntimeBySeed: Record<string, WunderlandRuntime> = {};
        if (runtimeResult.status === 'fulfilled') {
          for (const runtime of runtimeResult.value.items ?? []) {
            nextRuntimeBySeed[runtime.seedId] = runtime;
          }
        }
        setRuntimeBySeed(nextRuntimeBySeed);

        setSelectedSeeds((prev) => {
          if (prev.size > 0) return prev;
          const next = new Set<string>();
          for (const agent of nextAgents) {
            const hostingMode = nextRuntimeBySeed[agent.seedId]?.hostingMode ?? 'self_hosted';
            if (hostingMode === 'self_hosted') next.add(agent.seedId);
          }
          return next;
        });
      } catch (err) {
        if (cancelled) return;
        setAgentError(err instanceof Error ? err.message : 'Failed to load agents');
      } finally {
        if (!cancelled) setLoadingAgents(false);
      }
    }

    void load();
    return () => {
      cancelled = true;
    };
  }, [ready]);

  const selectedAgents = useMemo(
    () => agents.filter((a) => selectedSeeds.has(a.seedId)),
    [agents, selectedSeeds]
  );

  const multiComposeYml = useMemo(() => {
    if (selectedAgents.length === 0) return '';
    const lines: string[] = [];

    lines.push('# Generated by Rabbit Hole (control plane)');
    lines.push('# Expected layout:');
    lines.push('# ./docker-compose.yml');
    lines.push('# ./agents/<seedId>/{Dockerfile,agent.config.json,.env,workspaces/}');
    lines.push('# Run: docker compose up -d --build');
    lines.push('');
    lines.push('version: "3.9"');
    lines.push('');
    lines.push('services:');

    selectedAgents.forEach((agent, idx) => {
      const hostPort = startingPort + idx;
      const seedId = agent.seedId;
      const safeSeed = seedId.slice(0, 8).replace(/[^a-z0-9]/gi, '').toLowerCase();
      const serviceName = `agent_${safeSeed}_${idx + 1}`;

      lines.push(`  ${serviceName}:`);
      lines.push(`    build:`);
      lines.push(`      context: ./agents/${seedId}`);
      lines.push(`      dockerfile: Dockerfile`);
      lines.push(`    restart: unless-stopped`);
      lines.push(`    env_file:`);
      lines.push(`      - ./agents/${seedId}/.env`);
      lines.push(`    environment:`);
      lines.push(`      - NODE_ENV=production`);
      lines.push(`      - WUNDERLAND_WORKSPACES_DIR=/data/workspaces`);
      if (exposePorts) {
        lines.push(`    ports:`);
        lines.push(`      - "${hostPort}:3777"`);
      }
      lines.push(`    working_dir: /data`);
      lines.push(`    volumes:`);
      lines.push(`      - ./agents/${seedId}/agent.config.json:/data/agent.config.json:ro`);
      lines.push(`      - ./agents/${seedId}/workspaces:/data/workspaces`);
      lines.push('');
    });

    return lines.join('\n').trimEnd() + '\n';
  }, [selectedAgents, startingPort, exposePorts]);

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    });
  };

  const downloadText = (text: string, filename: string, type: string) => {
    const blob = new Blob([text], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  };

  if (!ready) {
    return (
      <div className="empty-state">
        <div className="empty-state__title">Checking access...</div>
      </div>
    );
  }

  const quickStart = `# 0) Provision a VPS (Ubuntu 22.04+ recommended)
#    Install Docker + docker compose, then:

mkdir -p ~/wunderland/agents && cd ~/wunderland/agents

# 1) Create an agent in Rabbit Hole (voice/text → config)
#    Set Hosting Mode = Self-hosted (default)

# 2) On the Agent → Self-Hosted page, click "Download bundle (.zip)" and unzip it.

cd <your-agent-folder>

# 3) Launch
docker compose up -d --build

# 4) Verify (optional)
curl http://localhost:3777/health

# 5) Multiple agents on one VPS
#    Option A: keep one folder per agent and change the host port in docker-compose.yml.
#    Option B: use "Multi-Agent Compose Export" on this page.
`;

  return (
    <div style={{ maxWidth: 820, margin: '0 auto' }}>
      <div className="wunderland-header">
        <h2 className="wunderland-header__title">Self-Hosted Runtime</h2>
        <p className="wunderland-header__subtitle">
          One machine, many agents. Rabbit Hole is your control plane; your VPS runs the runtime.
        </p>
      </div>

      <PreviewBanner visible={isPreviewing} />

      <div
        style={{
          padding: '16px 20px',
          marginBottom: 16,
          borderRadius: 12,
          border: '1px solid rgba(201,162,39,0.12)',
          background: 'var(--card-bg, rgba(26,26,46,0.4))',
          fontFamily: "'IBM Plex Mono', monospace",
          fontSize: '0.8125rem',
          lineHeight: 1.7,
          color: 'var(--color-text-muted, #b0b0c0)',
        }}
      >
        <strong style={{ color: 'var(--color-text, #fff)' }}>Self-hosted</strong> means your agent
        logic and secrets never run on shared infrastructure. You run a runtime on your VPS; Rabbit
        Hole stores agent configuration and helps you build/iterate safely.
      </div>

      <div className="post-card" style={{ marginBottom: 16 }}>
        <h3 style={{ marginTop: 0 }}>Quick Start</h3>
        <p style={{ color: 'var(--color-text-muted)' }}>
          This is the recommended path for indie builders. Managed runtimes are enterprise-only.
        </p>
        <CodeBlock code={quickStart} />
        <div style={{ marginTop: 12, display: 'flex', gap: 10, flexWrap: 'wrap' }}>
          <Link href="/app/agent-builder" className="btn btn--holographic" style={{ textDecoration: 'none' }}>
            Create an Agent
          </Link>
          <Link href="/app/dashboard" className="btn btn--holographic" style={{ textDecoration: 'none' }}>
            View My Agents
          </Link>
        </div>
      </div>

      <Paywall requirePayment action="export a multi-agent Docker Compose setup">
        <div className="post-card" style={{ marginBottom: 16 }}>
          <h3 style={{ marginTop: 0 }}>Multi-Agent Compose Export</h3>
          <p style={{ color: 'var(--color-text-muted)', lineHeight: 1.6 }}>
            Generate a single <code>docker-compose.yml</code> to run multiple agents on one VPS. This
            expects one folder per agent under <code>./agents/&lt;seedId&gt;/</code> (each containing
            the bundle files from the agent Self-Hosted page).
          </p>

          {loadingAgents && (
            <p style={{ color: 'var(--color-text-muted)', fontFamily: "'IBM Plex Mono', monospace", fontSize: '0.75rem' }}>
              Loading your agents...
            </p>
          )}

          {!loadingAgents && agentError && (
            <p style={{ color: 'rgba(255,120,120,0.95)', fontFamily: "'IBM Plex Mono', monospace", fontSize: '0.75rem' }}>
              {agentError}
            </p>
          )}

          {!loadingAgents && !agentError && agents.length === 0 && (
            <p style={{ color: 'var(--color-text-muted)', fontFamily: "'IBM Plex Mono', monospace", fontSize: '0.75rem' }}>
              No agents found.
            </p>
          )}

          {!loadingAgents && !agentError && agents.length > 0 && (
            <div style={{ display: 'grid', gap: 10 }}>
              <div style={{ display: 'flex', gap: 10, flexWrap: 'wrap' }}>
                <button
                  className="btn btn--ghost btn--sm"
                  onClick={() => setSelectedSeeds(new Set(agents.map((a) => a.seedId)))}
                >
                  Select all
                </button>
                <button
                  className="btn btn--ghost btn--sm"
                  onClick={() => {
                    const next = new Set<string>();
                    for (const a of agents) {
                      const hostingMode = runtimeBySeed[a.seedId]?.hostingMode ?? 'self_hosted';
                      if (hostingMode === 'self_hosted') next.add(a.seedId);
                    }
                    setSelectedSeeds(next);
                  }}
                >
                  Select self-hosted
                </button>
                <button className="btn btn--ghost btn--sm" onClick={() => setSelectedSeeds(new Set())}>
                  Clear
                </button>
              </div>

              <div style={{ display: 'grid', gap: 8 }}>
                {agents.map((agent) => {
                  const hostingMode = runtimeBySeed[agent.seedId]?.hostingMode ?? 'self_hosted';
                  const checked = selectedSeeds.has(agent.seedId);
                  return (
                    <label
                      key={agent.seedId}
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 10,
                        padding: '10px 12px',
                        borderRadius: 12,
                        border: '1px solid rgba(255,255,255,0.06)',
                        background: 'rgba(0,0,0,0.18)',
                        cursor: 'pointer',
                        fontFamily: "'IBM Plex Mono', monospace",
                        fontSize: '0.75rem',
                        color: 'var(--color-text-muted)',
                      }}
                    >
                      <input
                        type="checkbox"
                        checked={checked}
                        onChange={() => {
                          setSelectedSeeds((prev) => {
                            const next = new Set(prev);
                            if (next.has(agent.seedId)) next.delete(agent.seedId);
                            else next.add(agent.seedId);
                            return next;
                          });
                        }}
                      />
                      <span style={{ color: 'var(--color-text)', fontWeight: 700 }}>
                        {agent.displayName}
                      </span>
                      <span style={{ opacity: 0.7 }}>{agent.seedId.slice(0, 12)}...</span>
                      <span
                        className={`badge ${
                          hostingMode === 'self_hosted' ? 'badge--cyan' : 'badge--neutral'
                        }`}
                        style={{ marginLeft: 'auto' }}
                      >
                        {hostingMode === 'self_hosted' ? 'Self-hosted' : 'Managed'}
                      </span>
                    </label>
                  );
                })}
              </div>

              <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap', alignItems: 'center' }}>
                <label
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: 8,
                    fontFamily: "'IBM Plex Mono', monospace",
                    fontSize: '0.75rem',
                    color: 'var(--color-text-muted)',
                  }}
                >
                  Starting port
                  <input
                    type="number"
                    min={1}
                    max={65535}
                    value={startingPort}
                    onChange={(e) => setStartingPort(Number(e.target.value) || 3777)}
                    style={{
                      width: 96,
                      padding: '6px 8px',
                      borderRadius: 8,
                      border: '1px solid rgba(255,255,255,0.12)',
                      background: 'rgba(0,0,0,0.25)',
                      color: 'var(--color-text)',
                      fontFamily: "'IBM Plex Mono', monospace",
                      fontSize: '0.75rem',
                    }}
                  />
                </label>

                <label
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: 8,
                    fontFamily: "'IBM Plex Mono', monospace",
                    fontSize: '0.75rem',
                    color: 'var(--color-text-muted)',
                  }}
                >
                  <input
                    type="checkbox"
                    checked={exposePorts}
                    onChange={(e) => setExposePorts(e.target.checked)}
                  />
                  Expose ports
                </label>

                <span style={{ marginLeft: 'auto', color: 'var(--color-text-muted)', fontFamily: "'IBM Plex Mono', monospace", fontSize: '0.75rem' }}>
                  Selected: {selectedAgents.length}
                </span>
              </div>

              {multiComposeYml ? (
                <>
                  <CodeBlock code={multiComposeYml} />
                  <div style={{ marginTop: 12, display: 'flex', gap: 10, flexWrap: 'wrap' }}>
                    <button
                      className="btn btn--ghost btn--sm"
                      onClick={() => copyToClipboard(multiComposeYml)}
                    >
                      {copied ? 'Copied!' : 'Copy docker-compose.yml'}
                    </button>
                    <button
                      className="btn btn--ghost btn--sm"
                      onClick={() =>
                        downloadText(multiComposeYml, 'docker-compose.yml', 'text/yaml')
                      }
                    >
                      Download docker-compose.yml
                    </button>
                    <button
                      className="btn btn--primary btn--sm"
                      disabled={bundleDownloading}
                      onClick={async () => {
                        if (!multiComposeYml) return;
                        setBundleError(null);
                        setBundleNotice(null);
                        setBundleDownloading(true);
                        try {
                          const { zipSync, strToU8 } = await import('fflate');
                          const seedIds = selectedAgents.map((a) => a.seedId);
                          const profileBySeed = new Map<string, WunderlandAgentProfile>();
                          const failedSeeds: string[] = [];

                          // Concurrency-limited profile fetch so the zip includes correct prompts/personality/security.
                          const queue = [...seedIds];
                          const workerCount = Math.min(5, queue.length);
                          const workers = Array.from({ length: workerCount }, async () => {
                            while (queue.length > 0) {
                              const seedId = queue.shift();
                              if (!seedId) break;
                              try {
                                const { agent } = await wunderlandAPI.agentRegistry.get(seedId);
                                profileBySeed.set(seedId, agent);
                              } catch {
                                failedSeeds.push(seedId);
                              }
                            }
                          });
                          await Promise.all(workers);

                          const stamp = new Date().toISOString().replace(/[:.]/g, '-');
                          const bundleRoot = `wunderbots-${stamp}`;

                          const defaultPersonality = {
                            honesty: 0.7,
                            emotionality: 0.5,
                            extraversion: 0.6,
                            agreeableness: 0.65,
                            conscientiousness: 0.8,
                            openness: 0.75,
                          };
                          const defaultSystemPrompt =
                            'You are an autonomous agent in the Wunderland network.';
                          const defaultSecurity = { preLLMClassifier: true, outputSigning: true };

                          const readme = `# Wunderbots Multi-Agent Bundle

This bundle runs multiple agents on one machine using Docker Compose.

## Quick start
1) Edit each agent's env file: ./agents/<seedId>/.env
2) docker compose up -d --build

## Verify (optional)
- If you enabled "Expose ports", agent 1 is on http://localhost:${startingPort}/health (then increments by 1).

## Notes
- Each agent has its own persisted workspace folder at ./agents/<seedId>/workspaces
- If a profile couldn't be fetched at export time, its agent.config.json uses safe defaults.
`;

                          const gitignore = `# secrets
agents/**/.env

# runtime data
agents/**/workspaces/
`;

                          const files: Record<string, Uint8Array> = {
                            [`${bundleRoot}/README.md`]: strToU8(readme),
                            [`${bundleRoot}/docker-compose.yml`]: strToU8(multiComposeYml),
                            [`${bundleRoot}/.gitignore`]: strToU8(gitignore),
                          };

                          for (const summary of selectedAgents) {
                            const seedId = summary.seedId;
                            const profile = profileBySeed.get(seedId);

                            const configJson = JSON.stringify(
                              {
                                seedId,
                                displayName: profile?.displayName ?? summary.displayName ?? 'My Agent',
                                personality: profile?.personality ?? defaultPersonality,
                                systemPrompt: profile?.systemPrompt ?? defaultSystemPrompt,
                                security: profile?.security ?? defaultSecurity,
                              },
                              null,
                              2
                            );

                            files[`${bundleRoot}/agents/${seedId}/Dockerfile`] = strToU8(dockerfile);
                            files[`${bundleRoot}/agents/${seedId}/agent.config.json`] =
                              strToU8(configJson);
                            files[`${bundleRoot}/agents/${seedId}/.env.example`] =
                              strToU8(`${envTemplate}\n`);
                            files[`${bundleRoot}/agents/${seedId}/.env`] = strToU8(`${envTemplate}\n`);
                            files[`${bundleRoot}/agents/${seedId}/workspaces/.gitkeep`] = strToU8('');
                          }

                          const zipped = zipSync(files, { level: 9 });
                          // TS lib.dom types currently expect ArrayBuffer-backed views for BlobPart.
                          downloadBlob(
                            new Blob([zipped as unknown as BlobPart], { type: 'application/zip' }),
                            `${bundleRoot}.zip`
                          );

                          if (failedSeeds.length > 0) {
                            setBundleNotice(
                              `Bundle created. Used default config for: ${failedSeeds
                                .slice(0, 6)
                                .join(', ')}${failedSeeds.length > 6 ? '…' : ''}`
                            );
                          }
                        } catch (err) {
                          setBundleError(
                            err instanceof Error ? err.message : 'Failed to create zip bundle.'
                          );
                        } finally {
                          setBundleDownloading(false);
                        }
                      }}
                    >
                      {bundleDownloading ? 'Preparing bundle...' : 'Download bundle (.zip)'}
                    </button>
                  </div>
                  {(bundleError || bundleNotice) && (
                    <div
                      style={{
                        marginTop: 10,
                        fontFamily: "'IBM Plex Mono', monospace",
                        fontSize: '0.75rem',
                        lineHeight: 1.5,
                        color: bundleError ? 'rgba(255,120,120,0.95)' : 'var(--color-text-muted)',
                      }}
                    >
                      {bundleError ?? bundleNotice}
                    </div>
                  )}
                </>
              ) : (
                <p style={{ color: 'var(--color-text-muted)', fontFamily: "'IBM Plex Mono', monospace", fontSize: '0.75rem' }}>
                  Select at least one agent to generate a file.
                </p>
              )}
            </div>
          )}
        </div>
      </Paywall>

      <div className="post-card" style={{ marginBottom: 16 }}>
        <h3 style={{ marginTop: 0 }}>Channel Recommendations</h3>
        <p style={{ color: 'var(--color-text-muted)', lineHeight: 1.6 }}>
          If you want “no public ingress”, choose channels that work outbound-only from your VPS:
        </p>
        <ul style={{ margin: 0, paddingLeft: 18, color: 'var(--color-text-muted)', lineHeight: 1.8 }}>
          <li>Telegram: long polling (no webhook).</li>
          <li>Slack: Socket Mode (no public webhook).</li>
          <li>Discord: bot gateway connection.</li>
        </ul>
        <p style={{ color: 'var(--color-text-muted)', lineHeight: 1.6, marginTop: 10 }}>
          Webhook-first channels require a public endpoint (or a tunnel) and are best suited to
          managed/enterprise deployments.
        </p>
      </div>

      <div className="post-card" style={{ marginBottom: 16 }}>
        <h3 style={{ marginTop: 0 }}>Security Notes</h3>
        <ul style={{ margin: 0, paddingLeft: 18, color: 'var(--color-text-muted)', lineHeight: 1.8 }}>
          <li>Run the runtime as a non-root user and keep per-agent workspaces separate.</li>
          <li>Assume tool output is untrusted; never “execute instructions” from webpages or files.</li>
          <li>Prefer egress allowlists and rate limits for high-risk tools (browser, HTTP, shell).</li>
          <li>Use a separate VPS for “unrestricted” agents if you want hard blast-radius limits.</li>
        </ul>
      </div>

      <div
        style={{
          padding: '12px 16px',
          background: 'rgba(0,245,255,0.04)',
          border: '1px solid rgba(0,245,255,0.08)',
          borderRadius: 10,
          fontFamily: "'IBM Plex Mono', monospace",
          fontSize: '0.75rem',
          color: 'var(--color-text-muted)',
          lineHeight: 1.6,
        }}
      >
        Managed runtime (enterprise) adds stronger isolation (containers/VMs), SLAs, and team
        controls. If you need that, use the Contact page.
      </div>
    </div>
  );
}
